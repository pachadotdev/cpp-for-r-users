[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C++ for R Users",
    "section": "",
    "text": "Motivation\nThis is a collection of how I solved different C++ errors. Some of this required to check multiple sources and spend hours looking for online resources.\nIn particular, these notes follow the clas ECE244 (Programming Fundamentals) at the University of Toronto taught by Professor Salma Emara.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#honest-disclaimer",
    "href": "index.html#honest-disclaimer",
    "title": "C++ for R Users",
    "section": "Honest Disclaimer",
    "text": "Honest Disclaimer\nThese notes are a summary of what worked after hours of fails for my future self. I hope it helps you too.\nI am a Statistician and Political Scientist, not a Computer Scientist!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#rationale",
    "href": "index.html#rationale",
    "title": "C++ for R Users",
    "section": "Rationale",
    "text": "Rationale\nThese notes use the cpp11 package (Vaughan, Hester, and François 2024). This package is a modern C++ interface for R. It is a header-only library that allows you to write C++ code in R packages. All the examples in these notes use the cpp11 package.\nRcpp is another popular package for writing C++ code in R (Eddelbuettel et al. 2024). However, I will only cover some differences in the syntax between the two packages by the end of the notes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#organization",
    "href": "index.html#organization",
    "title": "C++ for R Users",
    "section": "Organization",
    "text": "Organization\nChapter 1 is about how to compile and run a C++ and how to test if R detects the compiler.\nChapters 2 to 7 provide different examples of C++ functions. These are organized into an R package, ece244, that also contains equivalent R functions for comparison. The goal of these chapters is to show the different syntax, compare the performance of the two languages, and show how to use C++ in R packages.\nThe ece244 package can be installed from GitHub with:\nremotes::install_github(\"pachadotdev/cpp11-r-examples\", subdir = \"ece244\")\nChapter 8 is about how tocreate R packages that use C++ code.\nChapter 9 covers some differences between cpp and Rcpp.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "C++ for R Users",
    "section": "References",
    "text": "References\n\n\n\n\nEddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Inaki Ucar, Douglas Bates, and John Chambers. 2024. Rcpp: Seamless r and c++ Integration. https://CRAN.R-project.org/package=Rcpp.\n\n\nVaughan, Davis, Jim Hester, and Romain François. 2024. Cpp11: A c++11 Interface for r’s c Interface. https://CRAN.R-project.org/package=cpp11.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "01-setup.html",
    "href": "01-setup.html",
    "title": "Setup",
    "section": "",
    "text": "C++ Setup\nTo install the required packages for C++ development, I ran the following command:\nI attempted to compile a simple example to print a number:\nWhen I tried to compile it with the following bash instruction:\nI encountered the following error:\nTo resolve this issue, I installed additional packages:\nAfter this, I was able to successfully compile and run the program from bash:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "01-setup.html#c-setup",
    "href": "01-setup.html#c-setup",
    "title": "Setup",
    "section": "",
    "text": "sudo apt install build-essential g++-11\n\n// save this as snippets/01-print-number.cpp\n\n#include &lt;iostream&gt; // required for the cout function\n\n// function to print a message\nint main() {\n    std::cout &lt;&lt; 1 &lt;&lt; std::endl;\n    return 0;\n}\n\ng++ snippets/01-print-number.cpp -o snippets/01-print-number\n\nfatal error: 'cstdio' file not found\nfatal error: 'vector' file not found\ncannot find -lc++abi: No such file or directory\n\nsudo apt install g++-11 libc++-11-dev libc++abi-11-dev\n\ng++ snippets/01-print-number.cpp -o snippets/01-print-number\n./snippets/01-print-number # prints \"1\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "01-setup.html#r-setup",
    "href": "01-setup.html#r-setup",
    "title": "Setup",
    "section": "R Setup",
    "text": "R Setup\nI installed the R packages bench, cpp11, devtools and usethis with the following command:\ninstall.packages(c(\"bench\", \"cpp11\", \"devtools\", \"usethis\"))\nTo verify that R can compile C++ code, I ran pkgbuild::check_build_tools(debug = TRUE), which returned the following output:\nTrying to compile a simple C file\nRunning /usr/lib/R/bin/R CMD SHLIB foo.c\nusing C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html",
    "href": "02-package-skeleton.html",
    "title": "Package Skeleton",
    "section": "",
    "text": "Motivation\n@cpp11 is better used when adding C++ code to R packages, as it allows for proper script organization and documentation. The reference for this chapter is @usethis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#loading-the-required-r-packages",
    "href": "02-package-skeleton.html#loading-the-required-r-packages",
    "title": "Package Skeleton",
    "section": "Loading the Required R Packages",
    "text": "Loading the Required R Packages\nThis chapter and the next use the following R packages:\nlibrary(cpp11)\nlibrary(devtools)\nlibrary(bench)\nlibrary(usethis)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#running-a-single-function",
    "href": "02-package-skeleton.html#running-a-single-function",
    "title": "Package Skeleton",
    "section": "Running a single function",
    "text": "Running a single function\nIt is possible to run a single function in C++ using the cpp11::cpp_source() function. For example, to create a function that adds one to a number, you can run:\n\ncpp11::cpp_source(\n  code = \"\n    #include &lt;cpp11.hpp&gt;\n\n    using namespace cpp11;\n\n    [[cpp11::register]] int plusone(int x) {\n      return x + 1;\n    }\",\n  quiet = FALSE\n)\n\nusing C++ compiler: ‘g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\nusing C++11\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpTmCuvy/file192d721b628fd/src/code_192d72ba3e49b.cpp -o /tmp/RtmpTmCuvy/file192d721b628fd/src/code_192d72ba3e49b.o\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpTmCuvy/file192d721b628fd/src/cpp11.cpp -o /tmp/RtmpTmCuvy/file192d721b628fd/src/cpp11.o\ng++ -std=gnu++11 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -flto=auto -ffat-lto-objects -flto=auto -Wl,-z,relro -o /tmp/RtmpTmCuvy/file192d721b628fd/src/code_192d72ba3e49b.so /tmp/RtmpTmCuvy/file192d721b628fd/src/code_192d72ba3e49b.o /tmp/RtmpTmCuvy/file192d721b628fd/src/cpp11.o -L/usr/lib/R/lib -lR\n\n\nThis function can be called from R by running plusone(2), which should return 3, or with any other integer.\nHowever, it is a much better practice to organize C++ code in an R package.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#creating-a-dummy-package",
    "href": "02-package-skeleton.html#creating-a-dummy-package",
    "title": "Package Skeleton",
    "section": "Creating a Dummy Package",
    "text": "Creating a Dummy Package\nI created a new package in RStudio (or VSCode) by running:\ncreate_package(\"~/github/cpp-for-r-users/ece244\")\nThis command created a new folder named ece244. Afterward, I ran use_cpp11() to add the necessary files for using C++ code within R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#print-a-number",
    "href": "02-package-skeleton.html#print-a-number",
    "title": "Package Skeleton",
    "section": "Print a Number",
    "text": "Print a Number\nI created a new R script by running use_r(\"ece244-package\"). I added the following code to the file:\n#' @useDynLib ece244, .registration = TRUE\nNULL\nThe usethis package automatically created the file src/code.cpp. I modified it to include a simple function that prints the number 1:\n#include \"cpp11.hpp\"\n\nusing namespace cpp11;\n\n[[cpp11::register]] int one_cpp_() { \n  return 1; \n}\nWithin R, there is no need to create a main() function in C++.\nThe R version of the function is as follows:\n#' Return 1 (R)\n#' @export\none_r &lt;- function() {\n    1L\n}\nTo export the C++ function, I added the following lines to ece244-package.R, which documents the function and allows for defining default argument values:\n#' Return 1 (C++)\n#' @export\none_cpp &lt;- function() {\n  one_cpp_()\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#numbers-sign",
    "href": "02-package-skeleton.html#numbers-sign",
    "title": "Package Skeleton",
    "section": "Number’s Sign",
    "text": "Number’s Sign\nA more complex function is one that returns the sign of a number:\n[[cpp11::register]] int sign_cpp_(double x) {\n  if (x &gt; 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}\nHere is the R version of the function:\n#' Return the sign of a number (R)\n#' @param x integer\n#' @export\nsign_r &lt;- function(x) {\n  if (x &gt; 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\nI also added the corresponding auxiliary function for documentation:\n#' Return the sign of a number (C++)\n#' @inheritParams sum_r\n#' @export\nsign_cpp &lt;- function(x) {\n  sign_cpp_(x)\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#installing-the-package",
    "href": "02-package-skeleton.html#installing-the-package",
    "title": "Package Skeleton",
    "section": "Installing the Package",
    "text": "Installing the Package\nTo document and install the package as an R library, I ran the next functions:\ncpp_register()\ndocument()\ninstall()\nAfterward, I could access the functions by loading the package with library(ece244).\nFor development and live testing, I used the load_all() function:\n\nload_all()\n\n── R CMD INSTALL ───────────────────────────────────────────────────────────────\n* installing *source* package ‘ece244’ ...\n** using staged installation\n** libs\nusing C++ compiler: ‘g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\ng++ -std=gnu++17 -I\"/usr/share/R/include\" -DNDEBUG  -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'    -Wall -O0 -pedantic -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2  -UNDEBUG -Wall -pedantic -g -O0  -c code.cpp -o code.o\ncode.cpp: In function ‘double squared_sum_non_iso_(cpp11::integers)’:\ncode.cpp:491:10: warning: ISO C++ forbids variable length array ‘array’ [-Wvla]\n  491 |   double array[size];  // will give a warning, but still compile\n      |          ^~~~~\ng++ -std=gnu++17 -I\"/usr/share/R/include\" -DNDEBUG  -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'    -Wall -O0 -pedantic -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2  -UNDEBUG -Wall -pedantic -g -O0  -c cpp11.cpp -o cpp11.o\ng++ -std=gnu++17 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -flto=auto -ffat-lto-objects -flto=auto -Wl,-z,relro -o ece244.so code.o cpp11.o -L/usr/lib/R/lib -lR\ninstalling to /tmp/RtmpTmCuvy/devtools_install_192d732aa0e98/00LOCK-cpp11-r-examples/00new/ece244/libs\n** checking absolute paths in shared objects and dynamic libraries\n* DONE (ece244)\n\n\nEach time I had to make changes to the C++ code, I ran load_all() again to test and then reinstalled the package.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#good-practice",
    "href": "02-package-skeleton.html#good-practice",
    "title": "Package Skeleton",
    "section": "Good Practice",
    "text": "Good Practice\nIt is good practice to include a license for your code. For example, you can use the Apache license by running:\nuse_apache_license()\nAdditionally, it is recommended to use use_build_ignore() to ignore files that are unnecessary for package installation. For example, to ignore the docs folder, you can run:\nuse_build_ignore(\"docs\")\nMy .Rbuildignore file includes the following lines, which I edited manually to exclude specific files and directories:\n^\\.vscode$\n^LICENSE\\.md$\n^ece244\\.Rproj$",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html",
    "href": "03-statistical-functions.html",
    "title": "Statistical Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple statistical functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#fair-warning",
    "href": "03-statistical-functions.html#fair-warning",
    "title": "Statistical Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#statistical-details",
    "href": "03-statistical-functions.html#statistical-details",
    "title": "Statistical Functions",
    "section": "Statistical details",
    "text": "Statistical details\nThe explanations and equations used for the functions are taken from @diez and @hansen. Some examples were adapted from @vaughan.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#load-the-package",
    "href": "03-statistical-functions.html#load-the-package",
    "title": "Statistical Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#additional-packages",
    "href": "03-statistical-functions.html#additional-packages",
    "title": "Statistical Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#sum-of-vector-elements-sum",
    "href": "03-statistical-functions.html#sum-of-vector-elements-sum",
    "title": "Statistical Functions",
    "section": "Sum of Vector Elements (sum())",
    "text": "Sum of Vector Elements (sum())\nFor a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\), the sum is calculated as:\n\\[\n\\sum_{i=1}^{n} x_i = x_1 + x_2 + \\ldots + x_n\n\\]\nThe following C++ function calculates the sum of a vector’s elements:\n[[cpp11::register]] double sum_cpp_(doubles x) {\n  int n = x.size();\n  double total = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total;\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “total” of type “double” and verify it is empty (double total = 0).\nFor each element \\(x_i\\) in the vector, take the element and add it to the total (total += x[i]).\nAfter \\(x_n\\) was added to the total, return the total (return total).\n\n\nIts R equivalent is:\n#' Return the sum of the coordinates of a vector (R)\n#' @param x numeric vector\n#' @export\nsum_r &lt;- function(x) {\n  total &lt;- 0\n  for (i in seq_along(x)) {\n    total &lt;- total + x[i]\n  }\n  total\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the sum of the coordinates of a vector (C++)\n#' @inheritParams sum_r\n#' @export\nsum_cpp &lt;- function(x) {\n  sum_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- runif(1e3) # 1,000,000 elements\n\nsum(x)\n\n[1] 497.2778\n\nsum_cpp(x)\n\n[1] 497.2778\n\nsum_r(x)\n\n[1] 497.2778\n\nmark(\n  sum(x),\n  sum_cpp(x),\n  sum_r(x)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum(x)        757ns  839.1ns  1113841.        0B      0  \n2 sum_cpp(x)    4.9µs    5.2µs   182946.        0B     18.3\n3 sum_r(x)     15.8µs   17.3µs    56435.    16.5KB      0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#arithmetic-mean-mean",
    "href": "03-statistical-functions.html#arithmetic-mean-mean",
    "title": "Statistical Functions",
    "section": "Arithmetic Mean (mean())",
    "text": "Arithmetic Mean (mean())\nThe arithmetic mean of a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) is calculated as:\n\\[\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n\\]\nThe following C++ function calculates the mean of a vector’s elements:\n[[cpp11::register]] double mean_cpp_(doubles x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    y += x[i];\n  }\n  return y / n;\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “y” of type “double” and verify it is empty (double y = 0).\nFor each element \\(x_i\\) in the vector, take the element and add it to the total (y += x[i]).\nAfter \\(x_n\\) was added to the total, return the total divided by the number of elements (return y / n).\n\n\nIts R equivalent is:\n#' Return the mean of a vector (R)\n#' @param x numeric vector\n#' @export\nmean_r &lt;- function(x) {\n  sum_r(x) / length(x)\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the mean of a vector (C++)\n#' @inheritParams mean_r\n#' @export\nmean_cpp &lt;- function(x) {\n  mean_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmean(x)\n\n[1] 0.4972778\n\nmean_cpp(x)\n\n[1] 0.4972778\n\nmean_r(x)\n\n[1] 0.4972778\n\nmark(\n  mean(x),\n  mean_cpp(x),\n  mean_r(x)\n)\n\n# A tibble: 3 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 mean(x)        2.9µs   3.43µs   269212.        0B    26.9 \n2 mean_cpp(x)   4.68µs    5.2µs   183173.        0B     0   \n3 mean_r(x)     16.6µs  17.76µs    54552.        0B     5.46",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#variance-var",
    "href": "03-statistical-functions.html#variance-var",
    "title": "Statistical Functions",
    "section": "Variance (var())",
    "text": "Variance (var())\nThe variance of a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) is calculated as:\n\\[\n\\text{Var}(x) = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\n\\]\nThe following C++ function calculates the variance of a vector’s elements:\n[[cpp11::register]] double var_cpp_(doubles x) {\n  int n = x.size();\n  double y1 = 0, y2 = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    y1 += x[i];\n    y2 += pow(x[i], 2.0);\n  }\n  return (y2 - pow(y1, 2.0) / n) / (n - 1);\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake two mixing bowls “y1” and “y2” of type “double” and verify they are empty (double y1 = 0, y2 = 0).\nFor each element \\(x_i\\) in the vector, take the element, add it to “y1” (y1 += x[i]), and then square it and\nadd it to “y2” (y2 += pow(x[i], 2.0)).\nAfter \\(x_n\\) was added to “y1” and “y2”, return the variance of the vector (return (y2 - pow(y1, 2.0) / n) / (n - 1)).\n\n\nIts R equivalent is:\n#' Return the variance of a vector (R)\n#' @param x numeric vector\n#' @export\nvar_r &lt;- function(x) {\n  mean_r((x - mean_r(x))^2)\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the variance of a vector (C++)\n#' @inheritParams var_r\n#' @export\nvar_cpp &lt;- function(x) {\n  var_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nvar(x)\n\n[1] 0.082647\n\nvar_cpp(x)\n\n[1] 0.082647\n\nvar_r(x)\n\n[1] 0.082647\n\nmark(\n  var(x),\n  var_cpp(x),\n  var_r(x)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 var(x)       5.53µs   6.98µs   131169.        0B    26.2 \n2 var_cpp(x)   23.2µs  24.43µs    40003.        0B     4.00\n3 var_r(x)    31.73µs  34.32µs    28537.    42.4KB     0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#root-mean-square-error-rmse",
    "href": "03-statistical-functions.html#root-mean-square-error-rmse",
    "title": "Statistical Functions",
    "section": "Root Mean Square Error (RMSE)",
    "text": "Root Mean Square Error (RMSE)\nThe RMSE function measures the differences between observed values and the true value.\nFor a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) and a value \\(x_0\\), the RMSE is calculated as:\n\\[\n\\text{RMSE}(x, x_0) = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - x_0)^2}\n\\]\nThe following C++ function calculates the difference of a vector’s elements to a value and returns the square root of the mean of the squared differences:\n[[cpp11::register]] double rmse_cpp_(doubles x, double x0) {\n  int n = x.size();\n  double y = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    y += pow(x[i] - x0, 2.0);\n  }\n  return sqrt(y / n);\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” and a value “x0” in a container of type “double” (doubles x, double x0).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “y” of type “double” and verify it is empty (double y = 0).\nFor each element \\(x_i\\) in the vector, take the element, subtract the value \\(x_0\\), square it, and add it to “y” (y += pow(x[i] - x0, 2.0)).\nAfter \\(x_n\\) was added to “y”, return the square root of the mean of the squared differences (return sqrt(y / n)).\n\n\nIts R equivalent is:\n#' Return the root mean square error (R)\n#' @param x numeric vector\n#' @param x0 numeric value\n#' @export\nrmse_r &lt;- function(x, x0) {\n  sqrt(sum((x - x0)^2) / length(x))\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the root mean square error (C++)\n#' @inheritParams rmse_r\n#' @export\nrmse_cpp &lt;- function(x, x0) {\n  rmse_cpp_(x, x0)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\n# create a list with 100 normal distributions with mean 0 and 1 million elements\nset.seed(123)\nx &lt;- list()\nfor (i in 1:1e3) {\n  x[[i]] &lt;- rnorm(1e3)\n}\n\n# compute the mean of each distribution\nx &lt;- sapply(x, mean)\n\nrmse_cpp(x, 0)\n\n[1] 0.03005874\n\nrmse_r(x, 0)\n\n[1] 0.03005874\n\nmark(\n  rmse_cpp(x, 0),\n  rmse_r(x, 0)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 rmse_cpp(x, 0)  19.56µs  20.61µs    47124.        0B     4.71\n2 rmse_r(x, 0)     2.49µs   4.37µs   220663.    7.86KB    22.1",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#references",
    "href": "03-statistical-functions.html#references",
    "title": "Statistical Functions",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html",
    "href": "04-logical-functions.html",
    "title": "Logical Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple logical functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance. These examples were adapted from @vaughan.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#fair-warning",
    "href": "04-logical-functions.html#fair-warning",
    "title": "Logical Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#load-the-package",
    "href": "04-logical-functions.html#load-the-package",
    "title": "Logical Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#additional-packages",
    "href": "04-logical-functions.html#additional-packages",
    "title": "Logical Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#are-some-values-true-any",
    "href": "04-logical-functions.html#are-some-values-true-any",
    "title": "Logical Functions",
    "section": "Are Some Values True? (any())",
    "text": "Are Some Values True? (any())\nThe any() function returns TRUE if there is at least one TRUE element in a vector, and FALSE otherwise. Below is one possible C++ implementation:\n[[cpp11::register]] bool any_cpp_(logicals x) {\n  int n = x.size();\n  \n  for (int i = 0; i &lt; n; ++i) {\n    if (x[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nIts R equivalent is:\n#' Return TRUE if any element in a vector is TRUE (R)\n#' @param x logical vector\n#' @export\nany_r &lt;- function(x) {\n  n &lt;- length(x)\n  \n  for (i in 1:n) {\n    if (x[i]) {\n      return(TRUE)\n    }\n  }\n  FALSE\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return TRUE if any element in a vector is TRUE (C++)\n#' @inheritParams any_r\n#' @export\nany_cpp &lt;- function(x) {\n  any_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\ny &lt;- ifelse(x &gt; 2, TRUE, FALSE)\n\nany(y)\n\n[1] TRUE\n\nany_cpp(y)\n\n[1] TRUE\n\nany_r(y)\n\n[1] TRUE\n\nmark(\n  any(y),\n  any_cpp(y),\n  any_r(y)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 any(y)        120ns    130ns  6188530.        0B      0  \n2 any_cpp(y)    862ns    941ns   896801.        0B     89.7\n3 any_r(y)      442ns    527ns  1624734.    19.5KB      0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#which-indices-are-true-which",
    "href": "04-logical-functions.html#which-indices-are-true-which",
    "title": "Logical Functions",
    "section": "Which Indices are TRUE? (which())",
    "text": "Which Indices are TRUE? (which())\nThe which() function returns the indices of the TRUE elements in a vector. Here is a possible C++ implementation:\n[[cpp11::register]] integers which_cpp_(logicals x) {\n  int n = x.size();\n  writable::integers res;\n  int j = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (x[i]) {\n      ++j;\n      res.push_back(i + 1);\n    }\n  }\n\n  if (j == 0) {\n    return integers(0);\n  } else {\n    return res;\n  }\n}\nIts R equivalent is:\n#' Return the indexes of the TRUE elements in a vector (R)\n#' @param x vector of values\n#' @export\nwhich_r &lt;- function(x) {\n  n &lt;- length(x)\n  res &lt;- c()\n  j &lt;- 0\n\n  for (i in 1:n) {\n    if (x[i]) {\n      res &lt;- c(res, i)\n      j &lt;- j + 1\n    }\n  }\n\n  if (j == 0) {\n    return(0)\n  } else {\n    return(res)\n  }\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the index of the TRUE elements in a vector (C++)\n#' @inheritParams which_r\n#' @export\nwhich_cpp &lt;- function(x) {\n  which_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nwhich(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nwhich_cpp(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nwhich_r(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nmark(\n  which(y[1:1000]),\n  which_cpp(y[1:1000]),\n  which_r(y[1:1000])\n)\n\n# A tibble: 3 × 6\n  expression                min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 which(y[1:1000])       3.73µs   4.29µs   200654.    13.2KB     60.2\n2 which_cpp(y[1:1000])  14.46µs  16.25µs    59158.    13.1KB     17.8\n3 which_r(y[1:1000])   111.56µs 127.42µs     7455.   250.9KB     36.4",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#are-all-values-true-all",
    "href": "04-logical-functions.html#are-all-values-true-all",
    "title": "Logical Functions",
    "section": "Are All Values True? (all())",
    "text": "Are All Values True? (all())\nThe all() function checks if all elements in a vector are TRUE. Here is a possible C++ implementation that loops over the vector:\n[[cpp11::register]] bool all_cpp_1_(logicals x) {\n  int n = x.size();\n  for (int i = 0; i &lt; n; ++i) {\n    if (!x[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nMore concise C++ alternatives are:\n[[cpp11::register]] bool all_cpp_2_(logicals x) {\n  for (int i = 0; i &lt; x.size(); ++i) {\n    if (!x[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n[[cpp11::register]] bool all_cpp_3_(logicals x) {\n  for (bool i : x) {\n    if (!i) {\n      return false;\n    }\n  }\n  return true;\n}\n\n[[cpp11::register]] bool all_cpp_4_(logicals x) {\n  return std::all_of(x.begin(), x.end(), [](bool x) { return x; });\n}\nTo avoid typing std:: every time, you can use using namespace std; at the top of src/code.cpp. However, this is not recommended because it can lead to conflicts. A better option is to declare using std::the_function; which means you can use the_function instead of std::the_function each time [@akbiggs].\nTo test the functions, I ran the following tests and benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\nall(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_1_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_2_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_3_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_4_(x &gt; 2)\n\n[1] FALSE\n\n# also test the TRUE-only case\nall(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_1_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_2_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_3_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_4_(x &gt;= 0)\n\n[1] TRUE\n\n\n\nmark(\n  all(x &gt; 2),\n  all_cpp_1_(x &gt; 2),\n  all_cpp_2_(x &gt; 2),\n  all_cpp_3_(x &gt; 2),\n  all_cpp_4_(x &gt; 2)\n)\n\n# A tibble: 5 × 6\n  expression             min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;        &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 all(x &gt; 2)          2.25ms   2.34ms      426.    3.81MB     61.6\n2 all_cpp_1_(x &gt; 2)    2.2ms   2.38ms      418.    3.81MB     69.7\n3 all_cpp_2_(x &gt; 2)   2.26ms   2.37ms      420.    3.81MB     61.1\n4 all_cpp_3_(x &gt; 2)   2.26ms   2.37ms      420.    3.81MB     61.7\n5 all_cpp_4_(x &gt; 2)   2.26ms   2.37ms      423.    3.81MB     67.8",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#references",
    "href": "04-logical-functions.html#references",
    "title": "Logical Functions",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html",
    "href": "05-rolling-functions.html",
    "title": "Rolling Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple rolling functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance. These examples were adapted from @vaughan.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#fair-warning",
    "href": "05-rolling-functions.html#fair-warning",
    "title": "Rolling Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#load-the-package",
    "href": "05-rolling-functions.html#load-the-package",
    "title": "Rolling Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#additional-packages",
    "href": "05-rolling-functions.html#additional-packages",
    "title": "Rolling Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nThe following packages are needed for visualizing and simplifying the presentation of the results:\n\nlibrary(bench)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(patchwork)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-sum-cumsum",
    "href": "05-rolling-functions.html#cumulative-sum-cumsum",
    "title": "Rolling Functions",
    "section": "Cumulative Sum (cumsum())",
    "text": "Cumulative Sum (cumsum())\nThe next function calculates the cumulative sum of a vector’s elements:\n[[cpp11::register]] doubles cumsum_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\nIts R equivalent is:\n#' Return the cumulative sum of a vector (R)\n#' @param x numeric vector\n#' @export\ncumsum_r &lt;- function(x) {\n  n &lt;- length(x)\n  out &lt;- numeric(n)\n  out[1] &lt;- x[1]\n  for (i in 2:n) {\n    out[i] &lt;- out[i - 1] + x[i]\n  }\n  out\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the cumulative sum of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncumsum_cpp &lt;- function(x) {\n  cumsum_cpp_(as.double(x))\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(1:3)\n\n[1] 1 3 6\n\ncumsum_cpp(1:3)\n\n[1] 1 3 6\n\ncumsum_r(1:3)\n\n[1] 1 3 6\n\nmark(\n  cumsum(x),\n  cumsum_cpp(x),\n  cumsum_r(x)\n)\n\n# A tibble: 3 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)       1.54ms   1.63ms     608.     3.81MB   124.  \n2 cumsum_cpp(x)  26.55ms  26.95ms      36.7   15.26MB    80.7 \n3 cumsum_r(x)     46.1ms   46.7ms      21.4    7.66MB     8.01",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-product-cumprod",
    "href": "05-rolling-functions.html#cumulative-product-cumprod",
    "title": "Rolling Functions",
    "section": "Cumulative Product (cumprod())",
    "text": "Cumulative Product (cumprod())\nR provides the cumprod() function to compute the cumulative product of a vector:\n\ncumprod(1:5)\n\n[1]   1   2   6  24 120\n\n\nOne possible C++ function to implement this is:\n[[cpp11::register]] doubles cumprod_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] * x[i];\n  }\n  return out;\n}\nIts R equivalent is:\n#' Return the cumulative product of a vector (R)\n#' @param x numeric vector\n#' @export\ncumprod_r &lt;- function(x) {\n  n &lt;- length(x)\n  out &lt;- numeric(n)\n  out[1] &lt;- x[1]\n  for (i in 2:n) {\n    out[i] &lt;- out[i - 1] * x[i]\n  }\n  out\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the cumulative product of a vector (C++)\n#' @inheritParams cumprod_r\n#' @export\ncumprod_cpp &lt;- function(x) {\n  cumprod_cpp_(as.double(x))\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmark(\n  cumprod(x),\n  cumprod_cpp(x),\n  cumprod_r(x)\n)\n\n# A tibble: 3 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)       1.73ms   2.15ms     309.    15.26MB    233. \n2 cumprod_cpp(x)  26.68ms  28.19ms      35.0   15.26MB     28.0\n3 cumprod_r(x)    46.44ms   46.7ms      21.4    7.63MB     12.2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#range-of-values-range",
    "href": "05-rolling-functions.html#range-of-values-range",
    "title": "Rolling Functions",
    "section": "Range of Values (range())",
    "text": "Range of Values (range())\nA simple example of the range() function in R is:\n\nrange(x)\n\n[1]  0 13\n\n\nOne possible C++ function to implement this is:\n[[cpp11::register]] doubles range_cpp_(doubles x) {\n  int n = x.size();\n  double x1 = x[0], x2 = x[0];\n\n  for (int i = 1; i &lt; n; ++i) {\n    x1 = std::min(x1, x[i]);\n    x2 = std::max(x2, x[i]);\n  }\n\n  writable::doubles out(2);\n  out[0] = x1;\n  out[1] = x2;\n\n  return out;\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the range of values in a vector (C++)\n#' @param x numeric vector\n#' @export\nrange_cpp &lt;- function(x) {\n  range_cpp_(as.double(x))\n}\nTo verify the functions, I ran the following tests and benchmark code in the R console:\n\nrange(x)\n\n[1]  0 13\n\nrange_cpp(x)\n\n[1]  0 13\n\n# create random vectors\nset.seed(123) # for reproducibility\nbigx &lt;- list(\n  as.double(rpois(2e6, lambda = 2)),\n  as.double(rpois(4e6, lambda = 2)),\n  as.double(rpois(8e6, lambda = 2)),\n  as.double(rpois(16e6, lambda = 2)),\n  as.double(rpois(32e6, lambda = 2)),\n  as.double(rpois(64e6, lambda = 2))\n)\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    range(.x),\n    range_cpp(.x)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#references",
    "href": "05-rolling-functions.html#references",
    "title": "Rolling Functions",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html",
    "href": "06-statistical-functions-2.html",
    "title": "Statistical Functions with Missing Values",
    "section": "",
    "text": "Motivation\nThe previous functions ignore NA values, which is not ideal for real-world data. This chapter introduces an additional argument and checks to the functions that allow the user to remove missing values (including NaN) from the vector. These examples were adapted from @vaughan.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#load-the-package",
    "href": "06-statistical-functions-2.html#load-the-package",
    "title": "Statistical Functions with Missing Values",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#additional-packages",
    "href": "06-statistical-functions-2.html#additional-packages",
    "title": "Statistical Functions with Missing Values",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "href": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "title": "Statistical Functions with Missing Values",
    "section": "Sum of Vector Elements (sum())",
    "text": "Sum of Vector Elements (sum())\nThe next function returns the sum of the elements of a vector:\n[[cpp11::register]] double sum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  double total = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      total += x[i];\n    }\n  }\n  return total;\n}\nUnlike the sum function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the sum of the elements of a vector (C++)\n#' @inheritParams sum_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  sum2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- runif(1e3) # 1,000 elements\nx[sample(1:1e3, 1e2)] &lt;- NA # randomly insert NA values\n\nsum(x, na.rm = FALSE)\n\n[1] NA\n\nsum2_cpp(x, na_rm = FALSE)\n\n[1] NA\n\nsum(x, na.rm = TRUE)\n\n[1] 447.4191\n\nsum2_cpp(x, na_rm = TRUE)\n\n[1] 447.4191\n\nmark(\n  sum(x, na.rm = TRUE),\n  sum2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum(x, na.rm = TRUE)         725ns    785ns  1184974.        0B     0   \n2 sum2_cpp(x, na_rm = TRUE)     10µs   10.6µs    91536.        0B     9.15",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "href": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "title": "Statistical Functions with Missing Values",
    "section": "Arithmetic Mean (mean())",
    "text": "Arithmetic Mean (mean())\nThe next function calculates the mean of the elements of a vector:\n[[cpp11::register]] double mean2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  \n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  double total = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      total += x[i];\n    }\n  }\n\n  return total / m;\n}\nUnlike the mean function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the mean of the elements of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nmean2_cpp &lt;- function(x, na_rm = FALSE) {\n  mean2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmean(x)\n\n[1] NA\n\nmean2_cpp(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 0.4971323\n\nmean2_cpp(x, na_rm = TRUE)\n\n[1] 0.4971323\n\nmark(\n  mean(x, na.rm = TRUE),\n  mean2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 mean(x, na.rm = TRUE)        5.72µs    7.1µs   116334.    22.5KB     58.2\n2 mean2_cpp(x, na_rm = TRUE)  15.54µs   16.7µs    58035.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#variance-var",
    "href": "06-statistical-functions-2.html#variance-var",
    "title": "Statistical Functions with Missing Values",
    "section": "Variance (var())",
    "text": "Variance (var())\nThe next function calculates the variance of a vector:\n[[cpp11::register]] double var2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  double total = 0, sq_total = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n      total += x[i];\n      sq_total += pow(x[i], 2);\n    }\n  }\n\n  if (m &lt;= 1) {\n    return NA_REAL;\n  }\n\n  return (sq_total - total * total / m) / (m - 1);\n}\nUnlike the variance function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the variance of the elements of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nvar2_cpp &lt;- function(x, na_rm = FALSE) {\n  var2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nvar(x)\n\n[1] NA\n\nvar2_cpp(x)\n\n[1] NA\n\nvar(x, na.rm = TRUE)\n\n[1] 0.08155043\n\nvar2_cpp(x, na_rm = TRUE)\n\n[1] 0.08155043\n\nmark(\n  var(x, na.rm = TRUE),\n  var2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 var(x, na.rm = TRUE)        6.01µs   7.49µs   126523.    3.95KB    25.3 \n2 var2_cpp(x, na_rm = TRUE)  38.56µs  39.72µs    24815.        0B     2.48",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#root-mean-square-error-rmse",
    "href": "06-statistical-functions-2.html#root-mean-square-error-rmse",
    "title": "Statistical Functions with Missing Values",
    "section": "Root Mean Square Error (RMSE)",
    "text": "Root Mean Square Error (RMSE)\nThe next function calculates the root mean square error between observed values (\\(x\\)) and the true value (\\(x_0\\)):\n[[cpp11::register]] double rmse2_cpp_(doubles x, double x0, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  double total = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n      total += pow(x[i] - x0, 2);\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  return sqrt(total / m);\n}\nUnlike the RMSE function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the root mean square error (C++)\n#' @inheritParams rmse_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nrmse2_cpp &lt;- function(x, x0, na_rm = FALSE) {\n  rmse2_cpp_(as.double(x), as.double(x0), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\n# create a list with 100 normal distributions with mean 0 and 1,000 elements each\nset.seed(123)\nx &lt;- list()\nfor (i in 1:1e3) {\n  x[[i]] &lt;- rnorm(1e3)\n}\n\n# compute the mean of each distribution\nx &lt;- sapply(x, mean)\n\n# insert NA values at random\nx[sample(1:1e3, 1e2)] &lt;- NA\n\nrmse2_cpp(x, 0)\n\n[1] NA\n\nrmse2_cpp(x, 0, na_rm = TRUE)\n\n[1] 0.02992032\n\nmark(\n  sqrt(mean((x - 0)^2, na.rm = TRUE)),\n  rmse2_cpp(x, 0, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                            min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                        &lt;bch:t&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sqrt(mean((x - 0)^2, na.rm = TRU…  6.96µs  8.26µs   114492.    30.4KB     68.7\n2 rmse2_cpp(x, 0, na_rm = TRUE)      27.7µs  30.6µs    31861.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#references",
    "href": "06-statistical-functions-2.html#references",
    "title": "Statistical Functions with Missing Values",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html",
    "href": "07-rolling-functions-2.html",
    "title": "Rolling functions with missing values",
    "section": "",
    "text": "Motivation\nThis chapter expands Chapter 5 by using the same methods from Chapter 5. These examples were adapted from @vaughan.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#load-the-package",
    "href": "07-rolling-functions-2.html#load-the-package",
    "title": "Rolling functions with missing values",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#additional-packages",
    "href": "07-rolling-functions-2.html#additional-packages",
    "title": "Rolling functions with missing values",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "href": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "title": "Rolling functions with missing values",
    "section": "Cumulative sum (cumsum())",
    "text": "Cumulative sum (cumsum())\nThe next function returns the cumulative sum of the elements of a vector:\n[[cpp11::register]] doubles cumsum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 + 0.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 0.0 + y2;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nUnlike the cumsum() function from Chapter 5, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative sum of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\ncumsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumsum2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 3 7\n\nmark(\n  cumsum(x),\n  cumsum2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)        1.71ms   2.05ms     424.     3.81MB     52.7\n2 cumsum2_cpp(x)  32.62ms  36.84ms      27.7   15.26MB     49.8",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "href": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "title": "Rolling functions with missing values",
    "section": "Cumulative product (cumprod())",
    "text": "Cumulative product (cumprod())\nThe next function calculates the cumulative product of the elements of a vector:\n[[cpp11::register]] doubles cumprod2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 * 1.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 1.0 * y2;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative product of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncumprod2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumprod2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncumprod(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 8\n\nmark(\n  cumprod(x),\n  cumprod2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)        1.81ms   2.08ms     328.     15.3MB    448. \n2 cumprod2_cpp(x)  31.41ms   33.7ms      29.8    15.3MB     26.1",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "href": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "title": "Rolling functions with missing values",
    "section": "Cumulative minimum (cummin())",
    "text": "Cumulative minimum (cummin())\nThe next function calculates the cumulative minimum of the elements of a vector:\n[[cpp11::register]] doubles cummin2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = x[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::min(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::min(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative minimum of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncummin2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummin2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncummin(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 1 1\n\nmark(\n  cummin(x),\n  cummin2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummin(x)        1.06ms   1.19ms     819.     3.81MB     85.6\n2 cummin2_cpp(x)  31.79ms  32.16ms      31.1   15.26MB     14.1",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "href": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "title": "Rolling functions with missing values",
    "section": "Cumulative maximum (cummax())",
    "text": "Cumulative maximum (cummax())\nThe next function calculates the cumulative maximum of the elements of a vector:\n[[cpp11::register]] doubles cummax2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::max(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::max(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative maximum of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncummax2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummax2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncummax(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 4\n\nmark(\n  cummax(x),\n  cummax2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummax(x)        1.01ms   1.11ms     741.     3.81MB     65.1\n2 cummax2_cpp(x)  31.11ms  32.01ms      30.7   15.26MB     23.9",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#references",
    "href": "07-rolling-functions-2.html#references",
    "title": "Rolling functions with missing values",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html",
    "href": "08-r-packages-expanded.html",
    "title": "Expanding R Packages Creation",
    "section": "",
    "text": "Motivation\n@cpp11 is better used when adding C++ code to R packages, as it allows for proper script organization and documentation. The previous package skeleton left out some essential details, such as testing for memory leaks and debugging. This chapter will cover these aspects in more detail. The references for this chapter are @vaughan, @padgham, @vaughan2, and @wickham.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html#load-the-package",
    "href": "08-r-packages-expanded.html#load-the-package",
    "title": "Expanding R Packages Creation",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html#compiler-setup",
    "href": "08-r-packages-expanded.html#compiler-setup",
    "title": "Expanding R Packages Creation",
    "section": "Compiler Setup",
    "text": "Compiler Setup\nTo test that my functions do not lead to memory errors, I created src/Makevars within the package folder and added:\nPKG_CXXFLAGS = -Wall -O0 -pedantic\nPKG_CPPFLAGS = -UDEBUG -g\nThis requires some explanations:\n\n-Wall: Enables all warnings.\n-O0: Disables optimizations for debugging purposes. Otherwise, compiler will adjust the package compiled binaries for speedups, making it harder to debug. Once your code is working, you can switch to -O2 or -O3 to enable optimizations for production. If you plan to submit the package to CRAN, remove the flag, they do not accept it.\n-pedantic: Enforces strict ISO C++ compliance. This will warn about improper writing, similar to bad grammar or spelling errors in English.\n-UDEBUG -g: Disables the DEBUG macro and enables debugging information. When a package is ready, -g can be removed to reduce the size of the compiled binaries.\n\nIn case that the “pedantic” part is not clear, here is an example:\n#include \"cpp11.hpp\"\n#include &lt;numeric&gt;\n\nusing namespace cpp11;\n\n// Non-ISO: Use a variable length array\n[[cpp11::register]] double squared_sum_non_iso_(integers inp) {\n  int size = inp.size();\n  double array[size];  // will give a warning, but still compile\n\n  for (int i = 0; i &lt; size; ++i) {\n    array[i] = inp[i] * inp[i];\n  }\n\n  return std::accumulate(array, array + size, 0.0);\n}\n\n// ISO: Use a vector\n[[cpp11::register]] double squared_sum_iso_(integers inp) {\n  int size = inp.size();\n  std::vector&lt;double&gt; vec(size);\n\n  for (int i = 0; i &lt; size; ++i) {\n    vec[i] = inp[i] * inp[i];\n  }\n\n  return std::accumulate(vec.begin(), vec.end(), 0.0);\n}\nEven when the code compiles, it gives a warning:\ncode.cpp:489:10: warning: ISO C++ forbids variable length array ‘array’ [-Wvla]\n  489 |   double array[size];  // will give a warning, but still compile\nIt is possible to verify that the functions are correct:\nall.equal(sum((1:5)^2), squared_sum_non_iso_(1:5), squared_sum_iso_(1:5))",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html#instructional-examples",
    "href": "08-r-packages-expanded.html#instructional-examples",
    "title": "Expanding R Packages Creation",
    "section": "Instructional examples",
    "text": "Instructional examples\n\nSolving a matrix using the Gauss-Jordan method\nThis example package covers the following topics:\n\nIntegers\nDoubles\nMatrices\nConditionals\nLoops (for)\nVendoring\n\nSee the cpp11gaussjordan package.\n\nDetails\nThis implementation is a naive approach, but it can be used, for example, to obtain the Ordinary Least Squares (OLS) estimator as shown in the next section.\nVendoring means that the dependency code, the cpp11 C++ headers, are copied the project’s source tree. This ensures the dependency code is fixed and stable until it is updated.\nThe advantage of vendoring is that changes to the cpp11 package could never break the package’s code. The disadvantage is that fixes and new features will be available after vendoring the code again.\n\n\nVendoring\nI started with create_package(\"~/github/cpp11gaussjordan\"). I used VSCode but all my steps also apply to RStudio.\nAfter opening ~/github/cpp11gaussjordan I ran use_cpp11() to have a readily availably skeleton in my project.\nI ran use_apache_licence() to have a LICENSE file and indicate in DESCRIPTION that my package is distributed under the Apache License.\nThen I ran cpp_vendor() to copy the C++ headers into inst/include.\n\n\nBuilding and testing\nI used devtools to build and test the package:\n# build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n# test\n\nA &lt;- matrix(c(2,1,3,-1), nrow = 2, ncol = 2)\ninvert_matrix(A)\n\n&gt; invert_matrix(A)\n     [,1] [,2]\n[1,]  0.2  0.6\n[2,]  0.2 -0.4\n\n\n\nNaive Ordinary Least Squares (OLS) estimator\nThis example package covers the following topics:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\n\nSee the cpp11ols package.\nThis implementation is extremely naive, quite similar to the Gauss-Jordan example with extra steps, and it is enough to show how to use C++ code within R.\nMy approach was to create one function per step, which means to create one function to obtain \\(X^tX\\), another for \\((X^tX)^{-1}\\) (e.g, implementing the Gauss-Jordan method to invert a matrix), another for \\(X^tY\\) and then call each of those functions to obtain \\(\\hat{\\beta} = (X^tX)^{-1}(X^tY)\\).\nA good challenge would be to implement the QR decomposition used by the lm() function in R and use it to obtain the OLS estimator in C++. @drury provides a good starting point, this is not trivial to implement.\nIt is hard to beat the performance of the lm() function in R, which calls compiled C and FORTRAN functions, and these functions are fast and robust lm().\n\n\nLinear programming (Simplex phase 2)\nThis example package covers the following topics:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\nLoops (for and while)\nMessages\n\nSee the cpp11simplex package.\n\nAlgorithm\nThe simplex algorithm is well described in Introduction to Linear Optimization and there is efficient software to solve this, including @lpsolve.\nA problem written in canonical form is represented by a table such as:\n\\[\n\\begin{array}{ccc|c}\nx_1 & \\cdots & x_n & \\\\\n\\hline\nc_1 & \\cdots & c_n & -z \\\\\na_{11} & \\cdots & a_{1n} & b_1 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\na_{m1} & \\cdots & a_{mn} & b_m\n\\end{array}\n\\]\nwhere \\(c_1, \\ldots, c_n\\) are the coefficients of the objective function (i.e., costs), \\(a_{11}, \\ldots, a_{mn}\\) are the coefficients of the constraints, and \\(b_1, \\ldots, b_m\\) are the right-hand side of the constraints.\nThe simplex algorithm to solve the problem consists in the next steps:\n\nIf \\(c_j \\geq 0\\) for all \\(j\\), then the current solution is optimal. Basic variables are equal to \\(b_i\\) and non-basic variables are equal to 0.\nIf \\(c_j &lt; 0\\) for some \\(j\\), we choose it to enter the base. We chose the variable with the most negative \\(c_j\\), let’s say that it is \\(j = s\\).\nIf \\(a_{is} \\leq 0\\) for all \\(i\\), then the problem is unbounded.\nIf \\(a_{is} &gt; 0\\) for some \\(i\\), we choose \\(i = r\\) such that \\(\\frac{b_r}{a_{rs}} = \\min(\\frac{b_i}{a_is},\\: a_{is} 0)\\) and pivot on \\(a_{rs}\\), to then go back to step 1.\n\nThe coefficients are updated according to:\n\n\\(a_{ij} \\leftarrow a_{ij} - \\frac{a_{is} a_{rj}}{a_{rs}}\\) for \\(j \\neq s\\)\n\\(a_{rj} \\leftarrow \\frac{a_{rj}}{a_{rs}}\\)\n\\(b_i \\leftarrow b_i - \\frac{a_{is} b_r}{a_{rs}}\\) for \\(i \\neq r\\)\n\\(b_r \\leftarrow \\frac{b_r}{a_{rs}}\\)\n\\(c_j \\leftarrow c_j - \\frac{c_s a_{rj}}{a_{rs}}\\)\n\\(-z \\leftarrow -z - \\frac{c_s b_r}{a_{rs}}\\)\n\nThis algorithm is equivalent to Gauss method to solve linear systems.\n\n\nNumerical example\nA simple example is the following minimization problem:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 \\\\\n\\text{subject to} \\quad & x_1 + x_2 \\geq 3 \\\\\n& -3x_1 + x_2 \\geq 2 \\\\\n& x_1, x_2 \\geq 0\n\\end{aligned}\n\\]\nIn canonical form, this problem is:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 + 0x_3 + 0x_4 \\\\\n\\text{subject to} \\quad & x_1 + x_2 + x_3 = 3 \\\\\n& -3x_1 + x_2 + x_4 = 2 \\\\\n& x_1, x_2,x_3,x_4 \\geq 0\n\\end{aligned}\n\\]\nThe initial tableau for the problem is:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-1 & -3 & 0 & 0 & 0 \\\\\n1 & 1 & 1 & 0 & 3 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThe first row is the cost row, the last column is the right-hand side, and the rest is the matrix \\(A\\).\nThe first step is to pivot on row 2 and column 2:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-10 & 0 & 0 & 3 & 6 \\\\\n4 & 0 & 1 & -1 & 1 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThe second step is to pivot on row 2 and column 1:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n0 & 0 & 5/2 & 1/2 & 17/2 \\\\\n1 & 0 & 1/4 & -1/4 & 1/4 \\\\\n0 & 1 & 3/4 & 1/4 & 11/4\n\\end{array}\n\\]\nHere we reached a stopping criterion: the minimum cost is non-negative, therefore the solution is optimal and is \\(x^* = (\\frac{1}{4}, \\frac{11}{4}, 0 , 0)\\) with an optimal value \\(z^* = -\\frac{17}{2}\\).\n\n\nBuilding and testing\nI used devtools to build and test the package:\n## build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n## test\n\nc &lt;- c(-1, -3)\nb &lt;- c(3, 2)\n\nA &lt;- matrix(\n    c(1, -3, 1, 1),\n    nrow = 2,\n    ncol = 2,\n    byrow = FALSE\n)\n\ncpp11_simplex_phase2(c, b, A)\nThe result should be:\nInitial tableau:\n-1 -3  0  0  0 \n 1  1  1  0  3 \n-3  1  0  1  2 \nMinimum cost: -3\nPivot row: 2\nPivot column: 2\n====\nNew tableau:\n-10  0  0  3  6 \n 4  0  1 -1  1 \n-3  1  0  1  2 \nMinimum cost: -10\nPivot row: 1\nPivot column: 1\n====\nNew tableau:\n 0  0  2.5  0.5  8.5 \n 1  0  0.25 -0.25  0.25 \n 0  1  0.75  0.25  2.75 \nMinimum cost: 0\nOptimal solution found in 2 steps !\n\n\n\nUsing OMP (parallelization)\nThis example package covers the following topics:\n\nIntegers\nDoubles\nLists (unnamed and named)\nLoops (for)\nOpenMP parallelization\n\nSee the cpp11omp package.\n\nMotivation\nOne common phrase that I find when I need to Google how to do something with cpp11 is: “cpp11 does not offer OpenMP support.” This is a myth. cpp11 does offer OpenMP support. The requirements are: A processor and C++ compiler that support OpenMP.\nI tested this on Windows, where you need to install Rtools, and Ubuntu where I didn’t need anything special because the gcc compiler comes with the operating system and it just works.\nIf you are using macOS, you need to install libomp via Homebrew in order to extend the clang compiler, and this is explained in the OpenBox documentation [@openbox].\n\n\nEnabling OpenMP\nI created an R package called cpp11omp with the following code:\nusethis::create_project(\"cpp11omp\")\nusethis::use_cpp11()\nThen, I created the file R/cpp11omp-package.R with the following contents:\n### usethis namespace: start\n#' @useDynLib cpp11omp, .registration = TRUE\n### usethis namespace: end\nNULL\nIn order to get the #pragma instruction to work, I needed to add the following to src/Makevars:\nPKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -DARMA_OPENMP_THREADS=1\nPKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS)\nCXX_STD = CXX11\nNot adding this means that the pragma instruction will be ignored and the functions will run in a single thread.\n\n\nUnnamed list\nI added a function called squared_unnamed_ in src/code.cpp that will square each element in a vector of doubles, so the file content corresponds to the following:\n#include &lt;cpp11.hpp&gt;\n#include &lt;omp.h&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] list squared_unnamed_(doubles x) {\n  // create vectors y = x^2 and z = thread number\n  int n = x.size();\n  writable::doubles y(n);\n  writable::doubles z(n);\n  \n  #pragma omp parallel for\n  for (int i = 0; i &lt; n; ++i) {\n    y[i] = x[i] * x[i];\n    z[i] = omp_get_thread_num();\n  }\n\n  //create a list containing y and z\n  writable::list out;\n  out.push_back(y);\n  out.push_back(z);\n  return out;\n}\nThe previous function returns an unnamed list with two elements: the squared vector and the thread number. The function is registered with [[cpp11::register]] so that it can be called from R.\nC++ is strict with types, so I need to create a wrapper function that will convert the integers to doubles to avoid accidental errors, it will go in R/cpp11omp-package.R:\n#' Unnamed list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_unnamed &lt;- function(x) {\n  squared_unnamed_(as.double(x))\n}\n\n\nNamed list\nI added a function called squared_named_ in src/code.cpp that does the same but returns a named list. The additional content corresponds to the following:\n[[cpp11::register]] list squared_named_(doubles x) {\n  // create vectors y = x^2 and z = thread number\n  int n = x.size();\n  writable::doubles y(n);\n  writable::doubles z(n);\n  \n  #pragma omp parallel for\n  for (int i = 0; i &lt; n; ++i) {\n    y[i] = x[i] * x[i];\n    z[i] = omp_get_thread_num();\n  }\n\n  //create a list containing y and z\n  writable::list out;\n  out.push_back({\"x^2\"_nm = y});\n  out.push_back({\"thread\"_nm = z});\n  return out;\n}\nAs in the previous part, I added a wrapper and documentation:\n#' Named list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_named &lt;- function(x) {\n  squared_named_(as.double(x))\n}\n\n\nBuilding and testing\nI used devtools to build and test the package:\ncpp11::cpp_register()\ndevtools::document()\ndevtools::install()\nThen, I tested the package from a new R session:\n&gt; library(cpp11omp)\n&gt; squared_unnamed(1:10)\n[[1]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[2]]\n [1] 0 0 1 1 2 3 4 5 6 7\n\n&gt; squared_named(1:10)\n$`x^2`\n [1]   1   4   9  16  25  36  49  64  81 100\n\n$thread\n [1] 0 0 1 1 2 3 4 5 6 7",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html#useful-rc-integration-examples",
    "href": "08-r-packages-expanded.html#useful-rc-integration-examples",
    "title": "Expanding R Packages Creation",
    "section": "Useful R/C++ Integration Examples",
    "text": "Useful R/C++ Integration Examples\nHere are some examples of C++ code integration with R using the cpp11 package:\n\narrow: An R package that provides bindings to the Arrow C++ library. Arrow is a\ncolumnar in-memory analytics format that is extremely fast and efficient.\ncpp11armadillo: An R package that provides bindings to the Armadillo C++ library. Armadiilo is a high-quality linear algebra library with a syntax similar to MATLAB.\ncpp11eigen: An R package that provides bindings to the Eigen C++ library. Eigen is a high-performance linear algebra library with a permisive license.\ncpp11tesseract: An R package that provides bindings to the Tesseract OCR\nC++ engine. This package allows to extract text from images.\nhaven: A package that reads and writes SPSS, Stata, and SAS files in R.\nkendallknight: Implements the Kendall’s correlation coefficient in C++, achieving speedup by using an algorithm with a complexity of \\(O(n \\log(n))\\) instead of \\(O(n^2)\\) in base R.\nmice: A package that imputes missing data using multivariate chained equations.\nredatam: C++ implementation of the Redatam file format, callable from both R and Python.\nRPostgres: A C++ interface to PostgreSQL using cpp11.\ntidyr: A package that uses C++ functions to reshape data frames.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "08-r-packages-expanded.html#references",
    "href": "08-r-packages-expanded.html#references",
    "title": "Expanding R Packages Creation",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Expanding R Packages Creation</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html",
    "href": "09-cpp11-rcpp.html",
    "title": "Differences between cpp11 and Rcpp",
    "section": "",
    "text": "Motivation\n@vaughan already provides some details. Here I will expand on the differences between cpp11 and Rcpp.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#read-and-write",
    "href": "09-cpp11-rcpp.html#read-and-write",
    "title": "Differences between cpp11 and Rcpp",
    "section": "Read and write",
    "text": "Read and write\nIn cpp11, when a variable is declared, it is read-only by default. This is different from Rcpp, where variables are read-write by default.\nThis code will not compile in cpp11:\n[[cpp11::register]] integers square_coordinates_(integers x) {\n  integers out = x;\n  for (int i = 0; i &lt; x.size(); ++i) {\n    out[i] = x[i] * x[i];\n  }\n  return out;\n}\nThe error message is:\ncode.cpp:515:10: error: lvalue required as left operand of assignment\n  515 |     out[i] = x[i] * x[i];\nTo fix this, you need to explicitly declare the variable as writable:\n[[cpp11::register]] integers square_coordinates_(integers x) {\n  writable::integers out = x;\n  for (int i = 0; i &lt; x.size(); ++i) {\n    out[i] = x[i] * x[i];\n  }\n  return out;\n}\nThe arguments are also read-only by default in cpp11, unless you declare them as writable, as in the following example:\n[[cpp11::register]] integers square_coordinates2_(writable::integers x) {\n  for (int i = 0; i &lt; x.size(); ++i) {\n    x[i] = x[i] * x[i];\n  }\n  return x;\n}",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#external-pointers",
    "href": "09-cpp11-rcpp.html#external-pointers",
    "title": "Differences between cpp11 and Rcpp",
    "section": "External pointers",
    "text": "External pointers\nIn cpp11, you can use external_pointer. In Rcpp, you can use XPtr to create external pointers. These have a quite different syntax, and cpp11 does not provide an attr method for external pointers.\nFor example, the cpp11tesseract package defines:\ntypedef cpp11::external_pointer&lt;tesseract::TessBaseAPI, tess_finalizer&gt; TessPtr;\nThen TessPtr is called with:\nTessPtr ptr(api);\nreturn ptr;\nAs a result, the R equivalent that the OCR C++ function verifies that the engine is such that the following is true:\nstopifnot(inherits(engine, \"externalptr\"))\nThe equivalent tesseract package, that uses Rcpp, defines:\ntypedef Rcpp::XPtr&lt;tesseract::TessBaseAPI, Rcpp::PreserveStorage, tess_finalizer, true&gt; TessPtr;\nThen TessPtr is called with:\nTessPtr ptr(api);\nptr.attr(\"class\") = Rcpp::CharacterVector::create(\"tesseract\");\nreturn ptr;\nSimilarly, the Rcpp version checks the engine with:\nstopifnot(inherits(engine, \"tesseract\"))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#references",
    "href": "09-cpp11-rcpp.html#references",
    "title": "Differences between cpp11 and Rcpp",
    "section": "References",
    "text": "References",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  }
]