[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C++ for R Users",
    "section": "",
    "text": "Motivation\nThis is a collection of how I solved different C++ errors. Some of this required to check multiple sources and spend hours looking for online resources.\nIn particular, these notes follow the clas ECE244 (Programming Fundamentals) at the University of Toronto taught by Professor Salma Emara.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#honest-disclaimer",
    "href": "index.html#honest-disclaimer",
    "title": "C++ for R Users",
    "section": "Honest Disclaimer",
    "text": "Honest Disclaimer\nThese notes are a summary of what worked after hours of fails for my future self. I hope it helps you too.\nI am a Statistician and Political Scientist, not a Computer Scientist!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#rationale",
    "href": "index.html#rationale",
    "title": "C++ for R Users",
    "section": "Rationale",
    "text": "Rationale\nThese notes use the cpp11 package (Vaughan, Hester, and François 2024). This package is a modern C++ interface for R. It is a header-only library that allows you to write C++ code in R packages. All the examples in these notes use the cpp11 package.\nRcpp is another popular package for writing C++ code in R (Eddelbuettel et al. 2024). However, I will only cover some differences in the syntax between the two packages by the end of the notes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#organization",
    "href": "index.html#organization",
    "title": "C++ for R Users",
    "section": "Organization",
    "text": "Organization\nChapter 1 is about how to compile and run a C++ and how to test if R detects the compiler.\nChapters 2 to 7 provide different examples of C++ functions. These are organized into an R package, ece244, that also contains equivalent R functions for comparison. The goal of these chapters is to show the different syntax, compare the performance of the two languages, and show how to use C++ in R packages.\nThe ece244 package can be installed from GitHub with:\nremotes::install_github(\"pachadotdev/cpp11-r-examples\", subdir = \"ece244\")\nChapter 8 is about how tocreate R packages that use C++ code.\nChapter 9 covers some differences between cpp and Rcpp.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "C++ for R Users",
    "section": "References",
    "text": "References\n\n\n\n\nEddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Inaki Ucar, Douglas Bates, and John Chambers. 2024. Rcpp: Seamless r and c++ Integration. https://CRAN.R-project.org/package=Rcpp.\n\n\nVaughan, Davis, Jim Hester, and Romain François. 2024. Cpp11: A c++11 Interface for r’s c Interface. https://CRAN.R-project.org/package=cpp11.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "01-setup.html",
    "href": "01-setup.html",
    "title": "Setup",
    "section": "",
    "text": "C++ Setup\nTo install the required packages for C++ development, I ran the following command:\nI attempted to compile a simple example to print a number:\nWhen I tried to compile it with the following bash instruction:\nI encountered the following error:\nTo resolve this issue, I installed additional packages:\nAfter this, I was able to successfully compile and run the program from bash:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "01-setup.html#c-setup",
    "href": "01-setup.html#c-setup",
    "title": "Setup",
    "section": "",
    "text": "sudo apt install build-essential g++-11\n\n// save this as snippets/01-print-number.cpp\n\n#include &lt;iostream&gt; // required for the cout function\n\n// function to print a message\nint main() {\n    std::cout &lt;&lt; 1 &lt;&lt; std::endl;\n    return 0;\n}\n\ng++ snippets/01-print-number.cpp -o snippets/01-print-number\n\nfatal error: 'cstdio' file not found\nfatal error: 'vector' file not found\ncannot find -lc++abi: No such file or directory\n\nsudo apt install g++-11 libc++-11-dev libc++abi-11-dev\n\ng++ snippets/01-print-number.cpp -o snippets/01-print-number\n./snippets/01-print-number # prints \"1\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "01-setup.html#r-setup",
    "href": "01-setup.html#r-setup",
    "title": "Setup",
    "section": "R Setup",
    "text": "R Setup\nI installed the R packages bench, cpp11, devtools and usethis with the following command:\ninstall.packages(c(\"bench\", \"cpp11\", \"devtools\", \"usethis\"))\nTo verify that R can compile C++ code, I ran pkgbuild::check_build_tools(debug = TRUE), which returned the following output:\nTrying to compile a simple C file\nRunning /usr/lib/R/bin/R CMD SHLIB foo.c\nusing C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Setup</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html",
    "href": "02-package-skeleton.html",
    "title": "Package Skeleton",
    "section": "",
    "text": "Motivation\nVaughan, Hester, and François (2024) is better used when adding C++ code to R packages, as it allows for proper script organization and documentation. The reference for this chapter is Wickham et al. (2024).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#loading-the-required-r-packages",
    "href": "02-package-skeleton.html#loading-the-required-r-packages",
    "title": "Package Skeleton",
    "section": "Loading the Required R Packages",
    "text": "Loading the Required R Packages\nThis chapter and the next use the following R packages:\nlibrary(cpp11)\nlibrary(devtools)\nlibrary(bench)\nlibrary(usethis)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#running-a-single-function",
    "href": "02-package-skeleton.html#running-a-single-function",
    "title": "Package Skeleton",
    "section": "Running a single function",
    "text": "Running a single function\nIt is possible to run a single function in C++ using the cpp11::cpp_source() function. For example, to create a function that adds one to a number, you can run:\n\ncpp11::cpp_source(\n  code = \"\n    #include &lt;cpp11.hpp&gt;\n\n    using namespace cpp11;\n\n    [[cpp11::register]] int plusone(int x) {\n      return x + 1;\n    }\",\n  quiet = FALSE\n)\n\nusing C++ compiler: ‘g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\nusing C++11\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpPVofZ2/file420f1c480e9/src/code_420f16bb38b82.cpp -o /tmp/RtmpPVofZ2/file420f1c480e9/src/code_420f16bb38b82.o\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpPVofZ2/file420f1c480e9/src/cpp11.cpp -o /tmp/RtmpPVofZ2/file420f1c480e9/src/cpp11.o\ng++ -std=gnu++11 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -flto=auto -ffat-lto-objects -flto=auto -Wl,-z,relro -o /tmp/RtmpPVofZ2/file420f1c480e9/src/code_420f16bb38b82.so /tmp/RtmpPVofZ2/file420f1c480e9/src/code_420f16bb38b82.o /tmp/RtmpPVofZ2/file420f1c480e9/src/cpp11.o -L/usr/lib/R/lib -lR\n\n\nThis function can be called from R by running plusone(2), which should return 3, or with any other integer.\nHowever, it is a much better practice to organize C++ code in an R package.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#creating-a-dummy-package",
    "href": "02-package-skeleton.html#creating-a-dummy-package",
    "title": "Package Skeleton",
    "section": "Creating a Dummy Package",
    "text": "Creating a Dummy Package\nI created a new package in RStudio (or VSCode) by running:\ncreate_package(\"~/github/cpp-for-r-users/ece244\")\nThis command created a new folder named ece244. Afterward, I ran use_cpp11() to add the necessary files for using C++ code within R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#print-a-number",
    "href": "02-package-skeleton.html#print-a-number",
    "title": "Package Skeleton",
    "section": "Print a Number",
    "text": "Print a Number\nI created a new R script by running use_r(\"ece244-package\"). I added the following code to the file:\n#' @useDynLib ece244, .registration = TRUE\nNULL\nThe usethis package automatically created the file src/code.cpp. I modified it to include a simple function that prints the number 1:\n#include \"cpp11.hpp\"\n\nusing namespace cpp11;\n\n[[cpp11::register]] int one_cpp_() { \n  return 1; \n}\nWithin R, there is no need to create a main() function in C++.\nThe R version of the function is as follows:\n#' Return 1 (R)\n#' @export\none_r &lt;- function() {\n    1L\n}\nTo export the C++ function, I added the following lines to ece244-package.R, which documents the function and allows for defining default argument values:\n#' Return 1 (C++)\n#' @export\none_cpp &lt;- function() {\n  one_cpp_()\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#numbers-sign",
    "href": "02-package-skeleton.html#numbers-sign",
    "title": "Package Skeleton",
    "section": "Number’s Sign",
    "text": "Number’s Sign\nA more complex function is one that returns the sign of a number:\n[[cpp11::register]] int sign_cpp_(double x) {\n  if (x &gt; 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}\nHere is the R version of the function:\n#' Return the sign of a number (R)\n#' @param x integer\n#' @export\nsign_r &lt;- function(x) {\n  if (x &gt; 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\nI also added the corresponding auxiliary function for documentation:\n#' Return the sign of a number (C++)\n#' @inheritParams sum_r\n#' @export\nsign_cpp &lt;- function(x) {\n  sign_cpp_(x)\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#installing-the-package",
    "href": "02-package-skeleton.html#installing-the-package",
    "title": "Package Skeleton",
    "section": "Installing the Package",
    "text": "Installing the Package\nTo document and install the package as an R library, I ran the next functions:\ncpp_register()\ndocument()\ninstall()\nAfterward, I could access the functions by loading the package with library(ece244).\nFor development and live testing, I used the load_all() function:\n\nload_all()\n\nEach time I had to make changes to the C++ code, I ran load_all() again to test and then reinstalled the package.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#good-practice",
    "href": "02-package-skeleton.html#good-practice",
    "title": "Package Skeleton",
    "section": "Good Practice",
    "text": "Good Practice\nIt is good practice to include a license for your code. For example, you can use the Apache license by running:\nuse_apache_license()\nAdditionally, it is recommended to use use_build_ignore() to ignore files that are unnecessary for package installation. For example, to ignore the docs folder, you can run:\nuse_build_ignore(\"docs\")\nMy .Rbuildignore file includes the following lines, which I edited manually to exclude specific files and directories:\n^\\.vscode$\n^LICENSE\\.md$\n^ece244\\.Rproj$",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "02-package-skeleton.html#references",
    "href": "02-package-skeleton.html#references",
    "title": "Package Skeleton",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Romain François. 2024. Cpp11: A c++11 Interface for r’s c Interface. https://CRAN.R-project.org/package=cpp11.\n\n\nWickham, Hadley, Jenny Bryan, Malcolm Barrett, and Andy Teucher. 2024. “Automate Package and Project Setup.” https://usethis.r-lib.org/.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Package Skeleton</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html",
    "href": "03-statistical-functions.html",
    "title": "Statistical Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple statistical functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#fair-warning",
    "href": "03-statistical-functions.html#fair-warning",
    "title": "Statistical Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#statistical-details",
    "href": "03-statistical-functions.html#statistical-details",
    "title": "Statistical Functions",
    "section": "Statistical details",
    "text": "Statistical details\nThe explanations and equations used for the functions are taken from Diez et al. (2015) and Hansen (2022). Some examples were adapted from Vaughan, Hester, and Francois (2024).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#load-the-package",
    "href": "03-statistical-functions.html#load-the-package",
    "title": "Statistical Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#additional-packages",
    "href": "03-statistical-functions.html#additional-packages",
    "title": "Statistical Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#sum-of-vector-elements-sum",
    "href": "03-statistical-functions.html#sum-of-vector-elements-sum",
    "title": "Statistical Functions",
    "section": "Sum of Vector Elements (sum())",
    "text": "Sum of Vector Elements (sum())\nFor a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\), the sum is calculated as:\n\\[\n\\sum_{i=1}^{n} x_i = x_1 + x_2 + \\ldots + x_n\n\\]\nThe following C++ function calculates the sum of a vector’s elements:\n[[cpp11::register]] double sum_cpp_(doubles x) {\n  int n = x.size();\n  double total = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total;\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “total” of type “double” and verify it is empty (double total = 0).\nFor each element \\(x_i\\) in the vector, take the element and add it to the total (total += x[i]).\nAfter \\(x_n\\) was added to the total, return the total (return total).\n\n\nIts R equivalent is:\n#' Return the sum of the coordinates of a vector (R)\n#' @param x numeric vector\n#' @export\nsum_r &lt;- function(x) {\n  total &lt;- 0\n  for (i in seq_along(x)) {\n    total &lt;- total + x[i]\n  }\n  total\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the sum of the coordinates of a vector (C++)\n#' @inheritParams sum_r\n#' @export\nsum_cpp &lt;- function(x) {\n  sum_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- runif(1e3) # 1,000,000 elements\n\nsum(x)\n\n[1] 497.2778\n\nsum_cpp(x)\n\n[1] 497.2778\n\nsum_r(x)\n\n[1] 497.2778\n\nmark(\n  sum(x),\n  sum_cpp(x),\n  sum_r(x)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum(x)     759.03ns 842.15ns  1061624.        0B    106. \n2 sum_cpp(x)   4.69µs   5.22µs   179337.        0B     17.9\n3 sum_r(x)    16.45µs   17.5µs    54858.    16.6KB      0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#arithmetic-mean-mean",
    "href": "03-statistical-functions.html#arithmetic-mean-mean",
    "title": "Statistical Functions",
    "section": "Arithmetic Mean (mean())",
    "text": "Arithmetic Mean (mean())\nThe arithmetic mean of a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) is calculated as:\n\\[\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n\\]\nThe following C++ function calculates the mean of a vector’s elements:\n[[cpp11::register]] double mean_cpp_(doubles x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    y += x[i];\n  }\n  return y / n;\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “y” of type “double” and verify it is empty (double y = 0).\nFor each element \\(x_i\\) in the vector, take the element and add it to the total (y += x[i]).\nAfter \\(x_n\\) was added to the total, return the total divided by the number of elements (return y / n).\n\n\nIts R equivalent is:\n#' Return the mean of a vector (R)\n#' @param x numeric vector\n#' @export\nmean_r &lt;- function(x) {\n  sum_r(x) / length(x)\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the mean of a vector (C++)\n#' @inheritParams mean_r\n#' @export\nmean_cpp &lt;- function(x) {\n  mean_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmean(x)\n\n[1] 0.4972778\n\nmean_cpp(x)\n\n[1] 0.4972778\n\nmean_r(x)\n\n[1] 0.4972778\n\nmark(\n  mean(x),\n  mean_cpp(x),\n  mean_r(x)\n)\n\n# A tibble: 3 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 mean(x)       3.17µs   4.69µs   211058.        0B    21.1 \n2 mean_cpp(x)   5.11µs   5.38µs   172074.        0B     0   \n3 mean_r(x)     17.1µs  18.16µs    52822.        0B     5.28",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#variance-var",
    "href": "03-statistical-functions.html#variance-var",
    "title": "Statistical Functions",
    "section": "Variance (var())",
    "text": "Variance (var())\nThe variance of a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) is calculated as:\n\\[\n\\text{Var}(x) = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\n\\]\nThe following C++ function calculates the variance of a vector’s elements:\n[[cpp11::register]] double var_cpp_(doubles x) {\n  int n = x.size();\n  double y1 = 0, y2 = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    y1 += x[i];\n    y2 += pow(x[i], 2.0);\n  }\n  return (y2 - pow(y1, 2.0) / n) / (n - 1);\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” (doubles x).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake two mixing bowls “y1” and “y2” of type “double” and verify they are empty (double y1 = 0, y2 = 0).\nFor each element \\(x_i\\) in the vector, take the element, add it to “y1” (y1 += x[i]), and then square it and\nadd it to “y2” (y2 += pow(x[i], 2.0)).\nAfter \\(x_n\\) was added to “y1” and “y2”, return the variance of the vector (return (y2 - pow(y1, 2.0) / n) / (n - 1)).\n\n\nIts R equivalent is:\n#' Return the variance of a vector (R)\n#' @param x numeric vector\n#' @export\nvar_r &lt;- function(x) {\n  mean_r((x - mean_r(x))^2)\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the variance of a vector (C++)\n#' @inheritParams var_r\n#' @export\nvar_cpp &lt;- function(x) {\n  var_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nvar(x)\n\n[1] 0.082647\n\nvar_cpp(x)\n\n[1] 0.082647\n\nvar_r(x)\n\n[1] 0.082647\n\nmark(\n  var(x),\n  var_cpp(x),\n  var_r(x)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 var(x)       5.51µs   7.12µs   131779.        0B     39.5\n2 var_cpp(x)  22.32µs  25.05µs    38863.        0B      0  \n3 var_r(x)    32.82µs  35.16µs    27834.    42.4KB      0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#root-mean-square-error-rmse",
    "href": "03-statistical-functions.html#root-mean-square-error-rmse",
    "title": "Statistical Functions",
    "section": "Root Mean Square Error (RMSE)",
    "text": "Root Mean Square Error (RMSE)\nThe RMSE function measures the differences between observed values and the true value.\nFor a vector of \\(n\\) elements \\(x_1, x_2, \\ldots, x_n\\) and a value \\(x_0\\), the RMSE is calculated as:\n\\[\n\\text{RMSE}(x, x_0) = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - x_0)^2}\n\\]\nThe following C++ function calculates the difference of a vector’s elements to a value and returns the square root of the mean of the squared differences:\n[[cpp11::register]] double rmse_cpp_(doubles x, double x0) {\n  int n = x.size();\n  double y = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    y += pow(x[i] - x0, 2.0);\n  }\n  return sqrt(y / n);\n}\nIf the previous function were a cooking recipe, it would be:\n\nIngredients: A vector “x” in a container of type “doubles” and a value “x0” in a container of type “double” (doubles x, double x0).\nPreparation:\n\nCount the vector’s coordinates and store the result in an integer variable “n” (int n = x.size()).\nTake a mixing bowl “y” of type “double” and verify it is empty (double y = 0).\nFor each element \\(x_i\\) in the vector, take the element, subtract the value \\(x_0\\), square it, and add it to “y” (y += pow(x[i] - x0, 2.0)).\nAfter \\(x_n\\) was added to “y”, return the square root of the mean of the squared differences (return sqrt(y / n)).\n\n\nIts R equivalent is:\n#' Return the root mean square error (R)\n#' @param x numeric vector\n#' @param x0 numeric value\n#' @export\nrmse_r &lt;- function(x, x0) {\n  sqrt(sum((x - x0)^2) / length(x))\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the root mean square error (C++)\n#' @inheritParams rmse_r\n#' @export\nrmse_cpp &lt;- function(x, x0) {\n  rmse_cpp_(x, x0)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\n# create a list with 100 normal distributions with mean 0 and 1 million elements\nset.seed(123)\nx &lt;- list()\nfor (i in 1:1e3) {\n  x[[i]] &lt;- rnorm(1e3)\n}\n\n# compute the mean of each distribution\nx &lt;- sapply(x, mean)\n\nrmse_cpp(x, 0)\n\n[1] 0.03005874\n\nrmse_r(x, 0)\n\n[1] 0.03005874\n\nmark(\n  rmse_cpp(x, 0),\n  rmse_r(x, 0)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 rmse_cpp(x, 0)  19.97µs  20.95µs    45795.        0B     4.58\n2 rmse_r(x, 0)     2.59µs   4.52µs   208579.    7.86KB    20.9",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "03-statistical-functions.html#references",
    "href": "03-statistical-functions.html#references",
    "title": "Statistical Functions",
    "section": "References",
    "text": "References\n\n\n\n\nDiez, David, Mine Cetinkaya-Rundel, Christopher Barr, and OpenIntro. 2015. OpenIntro Statistics. Leanpub. https://leanpub.next/os.\n\n\nHansen, Bruce E. 2022. Econometrics. Princeton, New Jersey: Princeton University Press.\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Statistical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html",
    "href": "04-logical-functions.html",
    "title": "Logical Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple logical functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance. These examples were adapted from Vaughan, Hester, and Francois (2024).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#fair-warning",
    "href": "04-logical-functions.html#fair-warning",
    "title": "Logical Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#load-the-package",
    "href": "04-logical-functions.html#load-the-package",
    "title": "Logical Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#additional-packages",
    "href": "04-logical-functions.html#additional-packages",
    "title": "Logical Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#are-some-values-true-any",
    "href": "04-logical-functions.html#are-some-values-true-any",
    "title": "Logical Functions",
    "section": "Are Some Values True? (any())",
    "text": "Are Some Values True? (any())\nThe any() function returns TRUE if there is at least one TRUE element in a vector, and FALSE otherwise. Below is one possible C++ implementation:\n[[cpp11::register]] bool any_cpp_(logicals x) {\n  int n = x.size();\n  \n  for (int i = 0; i &lt; n; ++i) {\n    if (x[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nIts R equivalent is:\n#' Return TRUE if any element in a vector is TRUE (R)\n#' @param x logical vector\n#' @export\nany_r &lt;- function(x) {\n  n &lt;- length(x)\n  \n  for (i in 1:n) {\n    if (x[i]) {\n      return(TRUE)\n    }\n  }\n  FALSE\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return TRUE if any element in a vector is TRUE (C++)\n#' @inheritParams any_r\n#' @export\nany_cpp &lt;- function(x) {\n  any_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\ny &lt;- ifelse(x &gt; 2, TRUE, FALSE)\n\nany(y)\n\n[1] TRUE\n\nany_cpp(y)\n\n[1] TRUE\n\nany_r(y)\n\n[1] TRUE\n\nmark(\n  any(y),\n  any_cpp(y),\n  any_r(y)\n)\n\n# A tibble: 3 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 any(y)        121ns    133ns  5039534.        0B    504. \n2 any_cpp(y)    865ns    958ns   929835.        0B     93.0\n3 any_r(y)      444ns    535ns  1589559.    19.5KB      0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#which-indices-are-true-which",
    "href": "04-logical-functions.html#which-indices-are-true-which",
    "title": "Logical Functions",
    "section": "Which Indices are TRUE? (which())",
    "text": "Which Indices are TRUE? (which())\nThe which() function returns the indices of the TRUE elements in a vector. Here is a possible C++ implementation:\n[[cpp11::register]] integers which_cpp_(logicals x) {\n  int n = x.size();\n  writable::integers res;\n  int j = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (x[i]) {\n      ++j;\n      res.push_back(i + 1);\n    }\n  }\n\n  if (j == 0) {\n    return integers(0);\n  } else {\n    return res;\n  }\n}\nIts R equivalent is:\n#' Return the indexes of the TRUE elements in a vector (R)\n#' @param x vector of values\n#' @export\nwhich_r &lt;- function(x) {\n  n &lt;- length(x)\n  res &lt;- c()\n  j &lt;- 0\n\n  for (i in 1:n) {\n    if (x[i]) {\n      res &lt;- c(res, i)\n      j &lt;- j + 1\n    }\n  }\n\n  if (j == 0) {\n    return(0)\n  } else {\n    return(res)\n  }\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the index of the TRUE elements in a vector (C++)\n#' @inheritParams which_r\n#' @export\nwhich_cpp &lt;- function(x) {\n  which_cpp_(x)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nwhich(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nwhich_cpp(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nwhich_r(y[1:100])\n\n [1]  2  4  5  8 11 13 16 20 21 22 24 26 31 32 33 34 37 50 53 58 59 65 67 68 69\n[26] 71 73 84 87 88 89 97\n\nmark(\n  which(y[1:1000]),\n  which_cpp(y[1:1000]),\n  which_r(y[1:1000])\n)\n\n# A tibble: 3 × 6\n  expression                min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 which(y[1:1000])       3.71µs   4.41µs   191852.    13.2KB     57.6\n2 which_cpp(y[1:1000])  15.55µs  17.04µs    55640.    13.1KB     16.7\n3 which_r(y[1:1000])   115.79µs 131.37µs     7159.   250.9KB     36.6",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#are-all-values-true-all",
    "href": "04-logical-functions.html#are-all-values-true-all",
    "title": "Logical Functions",
    "section": "Are All Values True? (all())",
    "text": "Are All Values True? (all())\nThe all() function checks if all elements in a vector are TRUE. Here is a possible C++ implementation that loops over the vector:\n[[cpp11::register]] bool all_cpp_1_(logicals x) {\n  int n = x.size();\n  for (int i = 0; i &lt; n; ++i) {\n    if (!x[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nMore concise C++ alternatives are:\n[[cpp11::register]] bool all_cpp_2_(logicals x) {\n  for (int i = 0; i &lt; x.size(); ++i) {\n    if (!x[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n[[cpp11::register]] bool all_cpp_3_(logicals x) {\n  for (bool i : x) {\n    if (!i) {\n      return false;\n    }\n  }\n  return true;\n}\n\n[[cpp11::register]] bool all_cpp_4_(logicals x) {\n  return std::all_of(x.begin(), x.end(), [](bool x) { return x; });\n}\nTo avoid typing std:: every time, you can use using namespace std; at the top of src/code.cpp. However, this is not recommended because it can lead to conflicts. A better option is to declare using std::the_function; which means you can use the_function instead of std::the_function each time (Akbiggs 2024).\nTo test the functions, I ran the following tests and benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\nall(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_1_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_2_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_3_(x &gt; 2)\n\n[1] FALSE\n\nall_cpp_4_(x &gt; 2)\n\n[1] FALSE\n\n# also test the TRUE-only case\nall(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_1_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_2_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_3_(x &gt;= 0)\n\n[1] TRUE\n\nall_cpp_4_(x &gt;= 0)\n\n[1] TRUE\n\n\n\nmark(\n  all(x &gt; 2),\n  all_cpp_1_(x &gt; 2),\n  all_cpp_2_(x &gt; 2),\n  all_cpp_3_(x &gt; 2),\n  all_cpp_4_(x &gt; 2)\n)\n\n# A tibble: 5 × 6\n  expression             min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;        &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 all(x &gt; 2)           2.2ms   2.41ms      411.    3.81MB     57.0\n2 all_cpp_1_(x &gt; 2)   2.33ms   2.43ms      410.    3.81MB     58.5\n3 all_cpp_2_(x &gt; 2)   2.32ms   2.43ms      409.    3.81MB     64.4\n4 all_cpp_3_(x &gt; 2)   2.29ms   2.47ms      402.    3.81MB     59.0\n5 all_cpp_4_(x &gt; 2)   2.32ms   2.45ms      404.    3.81MB     58.5",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "04-logical-functions.html#references",
    "href": "04-logical-functions.html#references",
    "title": "Logical Functions",
    "section": "References",
    "text": "References\n\n\n\n\nAkbiggs. 2024. “What’s the Problem with \"Using Namespace Std;\"?” Forum post. Stack Overflow. https://stackoverflow.com/q/1452721/3720258.\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Logical Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html",
    "href": "05-rolling-functions.html",
    "title": "Rolling Functions",
    "section": "",
    "text": "Motivation\nThis chapter covers the implementation of simple rolling functions in C++ and R. The goal is to show the syntax differences between the two languages and compare their performance. These examples were adapted from Vaughan, Hester, and Francois (2024).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#fair-warning",
    "href": "05-rolling-functions.html#fair-warning",
    "title": "Rolling Functions",
    "section": "Fair Warning",
    "text": "Fair Warning\nThese functions ignore NA values. Adjustments for handling NA values will be introduced in the sixth chapter.\nR already provides efficient versions of the functions covered here. Code optimizations and improvements will be made in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#load-the-package",
    "href": "05-rolling-functions.html#load-the-package",
    "title": "Rolling Functions",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#additional-packages",
    "href": "05-rolling-functions.html#additional-packages",
    "title": "Rolling Functions",
    "section": "Additional Packages",
    "text": "Additional Packages\nThe following packages are needed for visualizing and simplifying the presentation of the results:\n\nlibrary(bench)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(patchwork)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-sum-cumsum",
    "href": "05-rolling-functions.html#cumulative-sum-cumsum",
    "title": "Rolling Functions",
    "section": "Cumulative Sum (cumsum())",
    "text": "Cumulative Sum (cumsum())\nThe next function calculates the cumulative sum of a vector’s elements:\n[[cpp11::register]] doubles cumsum_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\nIts R equivalent is:\n#' Return the cumulative sum of a vector (R)\n#' @param x numeric vector\n#' @export\ncumsum_r &lt;- function(x) {\n  n &lt;- length(x)\n  out &lt;- numeric(n)\n  out[1] &lt;- x[1]\n  for (i in 2:n) {\n    out[i] &lt;- out[i - 1] + x[i]\n  }\n  out\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the cumulative sum of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncumsum_cpp &lt;- function(x) {\n  cumsum_cpp_(as.double(x))\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(1:3)\n\n[1] 1 3 6\n\ncumsum_cpp(1:3)\n\n[1] 1 3 6\n\ncumsum_r(1:3)\n\n[1] 1 3 6\n\nmark(\n  cumsum(x),\n  cumsum_cpp(x),\n  cumsum_r(x)\n)\n\n# A tibble: 3 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)       2.33ms   2.66ms     373.     3.81MB    43.0 \n2 cumsum_cpp(x)  29.15ms  30.02ms      32.2   15.26MB    32.2 \n3 cumsum_r(x)    52.02ms  52.16ms      19.1    7.66MB     8.20",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-product-cumprod",
    "href": "05-rolling-functions.html#cumulative-product-cumprod",
    "title": "Rolling Functions",
    "section": "Cumulative Product (cumprod())",
    "text": "Cumulative Product (cumprod())\nR provides the cumprod() function to compute the cumulative product of a vector:\n\ncumprod(1:5)\n\n[1]   1   2   6  24 120\n\n\nOne possible C++ function to implement this is:\n[[cpp11::register]] doubles cumprod_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] * x[i];\n  }\n  return out;\n}\nIts R equivalent is:\n#' Return the cumulative product of a vector (R)\n#' @param x numeric vector\n#' @export\ncumprod_r &lt;- function(x) {\n  n &lt;- length(x)\n  out &lt;- numeric(n)\n  out[1] &lt;- x[1]\n  for (i in 2:n) {\n    out[i] &lt;- out[i - 1] * x[i]\n  }\n  out\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the cumulative product of a vector (C++)\n#' @inheritParams cumprod_r\n#' @export\ncumprod_cpp &lt;- function(x) {\n  cumprod_cpp_(as.double(x))\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmark(\n  cumprod(x),\n  cumprod_cpp(x),\n  cumprod_r(x)\n)\n\n# A tibble: 3 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)       1.84ms   5.47ms     201.    15.26MB    90.2 \n2 cumprod_cpp(x)  29.27ms  33.57ms      30.8   15.26MB    14.0 \n3 cumprod_r(x)    54.81ms  55.06ms      18.1    7.63MB     2.59",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#range-of-values-range",
    "href": "05-rolling-functions.html#range-of-values-range",
    "title": "Rolling Functions",
    "section": "Range of Values (range())",
    "text": "Range of Values (range())\nA simple example of the range() function in R is:\n\nrange(x)\n\n[1]  0 13\n\n\nOne possible C++ function to implement this is:\n[[cpp11::register]] doubles range_cpp_(doubles x) {\n  int n = x.size();\n  double x1 = x[0], x2 = x[0];\n\n  for (int i = 1; i &lt; n; ++i) {\n    x1 = std::min(x1, x[i]);\n    x2 = std::max(x2, x[i]);\n  }\n\n  writable::doubles out(2);\n  out[0] = x1;\n  out[1] = x2;\n\n  return out;\n}\nTo document the C++ function, I added the following wrapper to the R code:\n#' Return the range of values in a vector (C++)\n#' @param x numeric vector\n#' @export\nrange_cpp &lt;- function(x) {\n  range_cpp_(as.double(x))\n}\nTo verify the functions, I ran the following tests and benchmark code in the R console:\n\nrange(x)\n\n[1]  0 13\n\nrange_cpp(x)\n\n[1]  0 13\n\n# create random vectors\nset.seed(123) # for reproducibility\nbigx &lt;- list(\n  as.double(rpois(2e6, lambda = 2)),\n  as.double(rpois(4e6, lambda = 2)),\n  as.double(rpois(8e6, lambda = 2)),\n  as.double(rpois(16e6, lambda = 2)),\n  as.double(rpois(32e6, lambda = 2)),\n  as.double(rpois(64e6, lambda = 2))\n)\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    range(.x),\n    range_cpp(.x)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#references",
    "href": "05-rolling-functions.html#references",
    "title": "Rolling Functions",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling Functions</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html",
    "href": "06-statistical-functions-2.html",
    "title": "Statistical Functions with Missing Values",
    "section": "",
    "text": "Motivation\nThe previous functions ignore NA values, which is not ideal for real-world data. This chapter introduces an additional argument and checks to the functions that allow the user to remove missing values (including NaN) from the vector. These examples were adapted from Vaughan, Hester, and Francois (2024).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#load-the-package",
    "href": "06-statistical-functions-2.html#load-the-package",
    "title": "Statistical Functions with Missing Values",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#additional-packages",
    "href": "06-statistical-functions-2.html#additional-packages",
    "title": "Statistical Functions with Missing Values",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "href": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "title": "Statistical Functions with Missing Values",
    "section": "Sum of Vector Elements (sum())",
    "text": "Sum of Vector Elements (sum())\nThe next function returns the sum of the elements of a vector:\n[[cpp11::register]] double sum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  double total = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      total += x[i];\n    }\n  }\n  return total;\n}\nUnlike the sum function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the sum of the elements of a vector (C++)\n#' @inheritParams sum_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  sum2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- runif(1e3) # 1,000 elements\nx[sample(1:1e3, 1e2)] &lt;- NA # randomly insert NA values\n\nsum(x, na.rm = FALSE)\n\n[1] NA\n\nsum2_cpp(x, na_rm = FALSE)\n\n[1] NA\n\nsum(x, na.rm = TRUE)\n\n[1] 447.4191\n\nsum2_cpp(x, na_rm = TRUE)\n\n[1] 447.4191\n\nmark(\n  sum(x, na.rm = TRUE),\n  sum2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum(x, na.rm = TRUE)         830ns  914.1ns   967313.        0B     0   \n2 sum2_cpp(x, na_rm = TRUE)   11.5µs   12.1µs    79724.        0B     7.97",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "href": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "title": "Statistical Functions with Missing Values",
    "section": "Arithmetic Mean (mean())",
    "text": "Arithmetic Mean (mean())\nThe next function calculates the mean of the elements of a vector:\n[[cpp11::register]] double mean2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  \n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  double total = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      total += x[i];\n    }\n  }\n\n  return total / m;\n}\nUnlike the mean function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the mean of the elements of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nmean2_cpp &lt;- function(x, na_rm = FALSE) {\n  mean2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nmean(x)\n\n[1] NA\n\nmean2_cpp(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 0.4971323\n\nmean2_cpp(x, na_rm = TRUE)\n\n[1] 0.4971323\n\nmark(\n  mean(x, na.rm = TRUE),\n  mean2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 mean(x, na.rm = TRUE)        6.18µs    7.5µs   110623.    22.5KB     44.3\n2 mean2_cpp(x, na_rm = TRUE)  17.53µs   19.1µs    51086.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#variance-var",
    "href": "06-statistical-functions-2.html#variance-var",
    "title": "Statistical Functions with Missing Values",
    "section": "Variance (var())",
    "text": "Variance (var())\nThe next function calculates the variance of a vector:\n[[cpp11::register]] double var2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  double total = 0, sq_total = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n      total += x[i];\n      sq_total += pow(x[i], 2);\n    }\n  }\n\n  if (m &lt;= 1) {\n    return NA_REAL;\n  }\n\n  return (sq_total - total * total / m) / (m - 1);\n}\nUnlike the variance function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the variance of the elements of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nvar2_cpp &lt;- function(x, na_rm = FALSE) {\n  var2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nvar(x)\n\n[1] NA\n\nvar2_cpp(x)\n\n[1] NA\n\nvar(x, na.rm = TRUE)\n\n[1] 0.08155043\n\nvar2_cpp(x, na_rm = TRUE)\n\n[1] 0.08155043\n\nmark(\n  var(x, na.rm = TRUE),\n  var2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 var(x, na.rm = TRUE)        6.72µs   8.37µs   112391.    3.95KB     33.7\n2 var2_cpp(x, na_rm = TRUE)  39.24µs  44.64µs    21989.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#root-mean-square-error-rmse",
    "href": "06-statistical-functions-2.html#root-mean-square-error-rmse",
    "title": "Statistical Functions with Missing Values",
    "section": "Root Mean Square Error (RMSE)",
    "text": "Root Mean Square Error (RMSE)\nThe next function calculates the root mean square error between observed values (\\(x\\)) and the true value (\\(x_0\\)):\n[[cpp11::register]] double rmse2_cpp_(doubles x, double x0, bool na_rm = false) {\n  int n = x.size();\n  int m = 0;\n  double total = 0;\n\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n      total += pow(x[i] - x0, 2);\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  return sqrt(total / m);\n}\nUnlike the RMSE function from Chapter 3, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the root mean square error (C++)\n#' @inheritParams rmse_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nrmse2_cpp &lt;- function(x, x0, na_rm = FALSE) {\n  rmse2_cpp_(as.double(x), as.double(x0), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\n# create a list with 100 normal distributions with mean 0 and 1,000 elements each\nset.seed(123)\nx &lt;- list()\nfor (i in 1:1e3) {\n  x[[i]] &lt;- rnorm(1e3)\n}\n\n# compute the mean of each distribution\nx &lt;- sapply(x, mean)\n\n# insert NA values at random\nx[sample(1:1e3, 1e2)] &lt;- NA\n\nrmse2_cpp(x, 0)\n\n[1] NA\n\nrmse2_cpp(x, 0, na_rm = TRUE)\n\n[1] 0.02992032\n\nmark(\n  sqrt(mean((x - 0)^2, na.rm = TRUE)),\n  rmse2_cpp(x, 0, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                            min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                         &lt;bch:&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sqrt(mean((x - 0)^2, na.rm = TRUE…  7.7µs  9.02µs   102173.    30.4KB     61.3\n2 rmse2_cpp(x, 0, na_rm = TRUE)      33.2µs 34.68µs    28173.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#references",
    "href": "06-statistical-functions-2.html#references",
    "title": "Statistical Functions with Missing Values",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical Functions with Missing Values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html",
    "href": "07-rolling-functions-2.html",
    "title": "Rolling functions with missing values",
    "section": "",
    "text": "Motivation\nThis chapter expands Chapter 5 by using the same methods from Chapter 5. These examples were adapted from Vaughan, Hester, and Francois (2024).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#load-the-package",
    "href": "07-rolling-functions-2.html#load-the-package",
    "title": "Rolling functions with missing values",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#additional-packages",
    "href": "07-rolling-functions-2.html#additional-packages",
    "title": "Rolling functions with missing values",
    "section": "Additional Packages",
    "text": "Additional Packages\nI used the bench package to compare the performance of the functions. The package was loaded with the following code:\n\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "href": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "title": "Rolling functions with missing values",
    "section": "Cumulative sum (cumsum())",
    "text": "Cumulative sum (cumsum())\nThe next function returns the cumulative sum of the elements of a vector:\n[[cpp11::register]] doubles cumsum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 + 0.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 0.0 + y2;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nUnlike the cumsum() function from Chapter 5, this function has an additional argument na_rm that allows the user to remove missing values (including NaN) from the vector.\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative sum of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\ncumsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumsum2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 3 7\n\nmark(\n  cumsum(x),\n  cumsum2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)         1.6ms   2.04ms     463.     3.81MB     59.9\n2 cumsum2_cpp(x)   29.1ms  32.65ms      31.3   15.26MB     78.3",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "href": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "title": "Rolling functions with missing values",
    "section": "Cumulative product (cumprod())",
    "text": "Cumulative product (cumprod())\nThe next function calculates the cumulative product of the elements of a vector:\n[[cpp11::register]] doubles cumprod2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 * 1.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 1.0 * y2;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative product of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncumprod2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumprod2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncumprod(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 8\n\nmark(\n  cumprod(x),\n  cumprod2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)        4.93ms   5.22ms     190.     15.3MB    190. \n2 cumprod2_cpp(x)  33.54ms  33.76ms      28.3    15.3MB     51.0",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "href": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "title": "Rolling functions with missing values",
    "section": "Cumulative minimum (cummin())",
    "text": "Cumulative minimum (cummin())\nThe next function calculates the cumulative minimum of the elements of a vector:\n[[cpp11::register]] doubles cummin2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = x[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::min(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::min(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative minimum of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncummin2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummin2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncummin(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 1 1\n\nmark(\n  cummin(x),\n  cummin2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummin(x)        1.05ms   1.12ms     837.     3.81MB    166. \n2 cummin2_cpp(x)  29.56ms  30.26ms      32.2   15.26MB     88.6",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "href": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "title": "Rolling functions with missing values",
    "section": "Cumulative maximum (cummax())",
    "text": "Cumulative maximum (cummax())\nThe next function calculates the cumulative maximum of the elements of a vector:\n[[cpp11::register]] doubles cummax2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::max(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::max(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nThe corresponding auxiliary function for documentation is:\n#' Return the cumulative maximum of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\ncummax2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummax2_cpp_(as.double(x), na_rm = na_rm)\n}\nTo test the functions, I ran the following benchmark code in the R console:\n\ncummax(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 4\n\nmark(\n  cummax(x),\n  cummax2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummax(x)         987µs   1.05ms     886.     3.81MB    111. \n2 cummax2_cpp(x)   28.9ms  29.73ms      33.5   15.26MB     50.2",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#references",
    "href": "07-rolling-functions-2.html#references",
    "title": "Rolling functions with missing values",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "08-debugging.html",
    "href": "08-debugging.html",
    "title": "Debugging R Packages",
    "section": "",
    "text": "Motivation\nThe previous package skeleton left out some essential details, such as testing for memory leaks and debugging. This chapter will cover these aspects in more detail. The references for this chapter are Vaughan, Hester, and Francois (2024), Padgham (2022), Vaughan (2019), Wickham and Bryan (2023), and R-pkg-devel (2024).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#load-the-package",
    "href": "08-debugging.html#load-the-package",
    "title": "Debugging R Packages",
    "section": "Load the Package",
    "text": "Load the Package\nI loaded the ece244 package as I added the functions from the next sections to it with the following code:\n\nload_all()",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#compiler-setup",
    "href": "08-debugging.html#compiler-setup",
    "title": "Debugging R Packages",
    "section": "Compiler Setup",
    "text": "Compiler Setup\nTo test that my functions do not lead to memory errors, I created src/Makevars within the package folder and added:\nPKG_CXXFLAGS = -Wall -O0 -pedantic\nPKG_CPPFLAGS = -UDEBUG -g\nOn Windows, the file is src/Makevars.win and the content is the same.\nThis requires some explanations:\n\n-Wall: Enables all warnings.\n-O0: Disables optimizations for debugging purposes. Otherwise, compiler will adjust the package compiled binaries for speedups, making it harder to debug. Once your code is working, you can switch to -O2 or -O3 to enable optimizations for production. If you plan to submit the package to CRAN, remove the flag, they do not accept it.\n-pedantic: Enforces strict ISO C++ compliance. This will warn about improper writing, similar to bad grammar or spelling errors in English.\n-UDEBUG -g: Disables the DEBUG macro and enables debugging information. When a package is ready, -g can be removed to reduce the size of the compiled binaries.\n\nIn case that the “pedantic” part is not clear, here is an example:\n#include \"cpp11.hpp\"\n#include &lt;numeric&gt;\n\nusing namespace cpp11;\n\n// Non-ISO: Use a variable length array\n[[cpp11::register]] double squared_sum_non_iso_(integers inp) {\n  int size = inp.size();\n  double array[size];  // will give a warning, but still compile\n\n  for (int i = 0; i &lt; size; ++i) {\n    array[i] = inp[i] * inp[i];\n  }\n\n  return std::accumulate(array, array + size, 0.0);\n}\n\n// ISO: Use a vector\n[[cpp11::register]] double squared_sum_iso_(integers inp) {\n  int size = inp.size();\n  std::vector&lt;double&gt; vec(size);\n\n  for (int i = 0; i &lt; size; ++i) {\n    vec[i] = inp[i] * inp[i];\n  }\n\n  return std::accumulate(vec.begin(), vec.end(), 0.0);\n}\nEven when the code compiles, it gives a warning:\ncode.cpp:489:10: warning: ISO C++ forbids variable length array ‘array’ [-Wvla]\n  489 |   double array[size];  // will give a warning, but still compile\nIt is possible to verify that the functions are correct:\nall.equal(sum((1:5)^2), squared_sum_non_iso_(1:5), squared_sum_iso_(1:5))",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#testing-for-memory-leaks",
    "href": "08-debugging.html#testing-for-memory-leaks",
    "title": "Debugging R Packages",
    "section": "Testing for Memory Leaks",
    "text": "Testing for Memory Leaks\nTo test for memory leaks, I used the valgrind tool. This tool is available on Linux and macOS.\nOne way to test for memory leaks is to run the following command in the terminal:\nvalgrind --leak-check=full Rscript -e \"library(ece244); squared_sum_iso_(1:5)\"\nOr, alternatively, to call R in vanilla mode:\nR --vanilla -d 'valgrind -s --track-origins=yes' -f test.R\nwith test.R containing:\nlibrary(ece244)\nsquared_sum_iso_(1:5)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#adding-a-configure-script",
    "href": "08-debugging.html#adding-a-configure-script",
    "title": "Debugging R Packages",
    "section": "Adding a configure script",
    "text": "Adding a configure script\nFor a portable package, it is recommended to add a configure script. This script will check for the necessary tools to build the package. The script is written in bash and is placed in the configure file in the package root directory.\nHere is an example of a configure script for the ece244 package:\n#!/bin/sh\n\nPKG_CONFIG_NAME=\"gccsanissue\"\n\npkg-config --version &gt;/dev/null 2&gt;&1\nif [ $? -eq 0 ]; then\n  PKGCONFIG_CFLAGS=`pkg-config --cflags --silence-errors`\n  PKGCONFIG_LIBS=`pkg-config --libs`\nfi\n\nif [ \"$PKGCONFIG_CFLAGS\" ] || [ \"$PKGCONFIG_LIBS\" ]; then\n  echo \"Found pkg-config cflags and libs!\"\n  PKG_CFLAGS=${PKGCONFIG_CFLAGS}\n  PKG_LIBS=${PKGCONFIG_LIBS}\nfi\n\nCXXFLAGS=\"-stdlib=libc++\"\n# CXXFLAGS=\"-O0 -g -stdlib=libc++\"\n\nLDFLAGS=\"-stdlib=libc++\"\n\nsed -e \"s|@cxxflags@|$CXXFLAGS|\" \\\n    -e \"s|@ldflags@|$LDFLAGS|\" \\\n    src/Makevars.in &gt; src/Makevars\n\nexit 0\nThis file, meant for Unix systems, must be accompanied by an configure.win file for Windows systems.\nBesides the configure script, an src/Makevars.in file must be created. This file is a template for the src/Makevars file. Here is an example:\nLDFLAGS=@ldflags@\n\n# Convert source files to object files\nSOURCES = code.cpp \\\n                    cpp11.cpp\nOBJECTS = $(SOURCES:.cpp=.o)\n\nall: $(SHLIB)\n\n$(SHLIB): $(OBJECTS)\n\nclean: rm -f $(OBJECTS) $(SHLIB)\nMakevars.in is also for Unix systems, and it must be accompanied by an empty Makevars.win for Windows systems.\nFinally, a cleanup script helps to get a tidy package build. Here is an example:\n#!/bin/sh\nrm -f src/Makevars configure.log\nThe advantage of this approach is that it will create a src/Makevars file with the correct flags for the system. This way, the package will be portable and easier to test with GitHub Actions or Docker.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#testing-with-docker",
    "href": "08-debugging.html#testing-with-docker",
    "title": "Debugging R Packages",
    "section": "Testing with Docker",
    "text": "Testing with Docker\nCRAN checks packages on different Unix platforms, and additional tests for compiled code include testing for memory leaks with valgrind and address sanitizer.\nDerived from the recommendations made by Dr. Krylov and Dr. Eddelbuettel in the R-pkg-devel mailing list, I created the following script to test the package in a Docker container:\n#!/bin/sh\n\nPACKAGE_DIR=$(pwd)\n\n# DOCKER_IMAGE=\"ghcr.io/r-hub/containers/valgrind:latest\"\nDOCKER_IMAGE=\"ghcr.io/r-hub/containers/clang-asan:latest\"\n\ndocker pull $DOCKER_IMAGE\n\ndocker run --rm -v \"$PACKAGE_DIR\":/workspace -w /workspace $DOCKER_IMAGE bash -c \"\n  Rscript -e 'install.packages(\\\"cpp11\\\", repos=\\\"https://cran.rstudio.com/\\\")'\n  R CMD build .\n  R CMD check --as-cran --no-manual gccsanissue_0.1.0.tar.gz\n\"\nI added the following function to ece244:\n[[cpp11::register]] int bad_() {\n  int x = 42;    // valid integer\n  int *ptr = &x; // pointer to `x`\n\n  // undefined behavior (alignment issue)\n  auto misaligned_ptr = reinterpret_cast&lt;long*&gt;(ptr);\n  return *misaligned_ptr; // Read through misaligned pointer\n}\nTo access the function from the R session, I added the following R code:\n#' @title Bad function\n#' @description This function has a GCC SAN issue\n#' @export \n#' @examples \n#' bad()\nbad &lt;- function() {\n  bad_()\n}\nThe function bad_ introduces undefined behavior by reading through a misaligned pointer. This is a common issue in C++ code, and it is a good example to test the address sanitizer.\nreinterpret_cast&lt;long*&gt; creates a misaligned pointer since ptr is aligned for int, not long. The pointer dereference *misaligned_ptr introduces an undefined behavior. Without sanitizers, this will silently execute, and it returns the value of x. With sanitizers, it will throw an error.\nWhen testing with the valgrind container and the command bash dev/test-docker.sh, the R checks will pass, but the valgrind check will fail with the following error:\nShadow bytes around the buggy address:\n  0x6ffdc4008d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==1244==ABORTING",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "08-debugging.html#references",
    "href": "08-debugging.html#references",
    "title": "Debugging R Packages",
    "section": "References",
    "text": "References\n\n\n\n\nPadgham, Mark. 2022. “Debugging in R with a Single Command.” https://mpadge.github.io/blog/blog012.html.\n\n\nR-pkg-devel. 2024. “[R-Pkg-Devel] Possible False Negative for Compiled C++ Code in CRAN Checks.” https://stat.ethz.ch/pipermail/r-package-devel/2024q4/011193.html.\n\n\nVaughan, Davis. 2019. “Debugging an R Package with C++ – Davis Vaughan.” https://blog.davisvaughan.com/posts/2019-04-05-debug-r-package-with-cpp/.\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.\n\n\nWickham, Hadley, and Jenny Bryan. 2023. “R Packages (2e).” https://r-pkgs.org/.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html",
    "href": "09-cpp11-rcpp.html",
    "title": "Differences between cpp11 and Rcpp",
    "section": "",
    "text": "Motivation\nVaughan, Hester, and Francois (2024) already provides some details. Here I will expand on the differences between cpp11 and Rcpp.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#read-and-write",
    "href": "09-cpp11-rcpp.html#read-and-write",
    "title": "Differences between cpp11 and Rcpp",
    "section": "Read and write",
    "text": "Read and write\nIn cpp11, when a variable is declared, it is read-only by default. This is different from Rcpp, where variables are read-write by default.\nThis code will not compile in cpp11:\n[[cpp11::register]] integers square_coordinates_(integers x) {\n  integers out = x;\n  for (int i = 0; i &lt; x.size(); ++i) {\n    out[i] = x[i] * x[i];\n  }\n  return out;\n}\nThe error message is:\ncode.cpp:515:10: error: lvalue required as left operand of assignment\n  515 |     out[i] = x[i] * x[i];\nTo fix this, you need to explicitly declare the variable as writable:\n[[cpp11::register]] integers square_coordinates_(integers x) {\n  writable::integers out = x;\n  for (int i = 0; i &lt; x.size(); ++i) {\n    out[i] = x[i] * x[i];\n  }\n  return out;\n}\nThe arguments are also read-only by default in cpp11, unless you declare them as writable, as in the following example:\n[[cpp11::register]] integers square_coordinates2_(writable::integers x) {\n  for (int i = 0; i &lt; x.size(); ++i) {\n    x[i] = x[i] * x[i];\n  }\n  return x;\n}",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#external-pointers",
    "href": "09-cpp11-rcpp.html#external-pointers",
    "title": "Differences between cpp11 and Rcpp",
    "section": "External pointers",
    "text": "External pointers\nIn cpp11, you can use external_pointer. In Rcpp, you can use XPtr to create external pointers. These have a quite different syntax, and cpp11 does not provide an attr method for external pointers.\nFor example, the cpp11tesseract package defines:\ntypedef cpp11::external_pointer&lt;tesseract::TessBaseAPI, tess_finalizer&gt; TessPtr;\nThen TessPtr is called with:\nTessPtr ptr(api);\nreturn ptr;\nAs a result, the R equivalent that the OCR C++ function verifies that the engine is such that the following is true:\nstopifnot(inherits(engine, \"externalptr\"))\nThe equivalent tesseract package, that uses Rcpp, defines:\ntypedef Rcpp::XPtr&lt;tesseract::TessBaseAPI, Rcpp::PreserveStorage, tess_finalizer, true&gt; TessPtr;\nThen TessPtr is called with:\nTessPtr ptr(api);\nptr.attr(\"class\") = Rcpp::CharacterVector::create(\"tesseract\");\nreturn ptr;\nSimilarly, the Rcpp version checks the engine with:\nstopifnot(inherits(engine, \"tesseract\"))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "09-cpp11-rcpp.html#references",
    "href": "09-cpp11-rcpp.html#references",
    "title": "Differences between cpp11 and Rcpp",
    "section": "References",
    "text": "References\n\n\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Differences between cpp11 and Rcpp</span>"
    ]
  },
  {
    "objectID": "10-worked-examples.html",
    "href": "10-worked-examples.html",
    "title": "Debugging R Packages",
    "section": "",
    "text": "Motivation\nThe previous package skeleton left out some essential details, such as testing for memory leaks and debugging. This chapter will cover these aspects in more detail. The references for this chapter are Vaughan, Hester, and Francois (2024), Padgham (2022), Vaughan (2019), and Wickham and Bryan (2023).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "10-worked-examples.html#instructional-examples",
    "href": "10-worked-examples.html#instructional-examples",
    "title": "Debugging R Packages",
    "section": "Instructional examples",
    "text": "Instructional examples\n\nSolving a matrix using the Gauss-Jordan method\nThis example package covers the following topics:\n\nIntegers\nDoubles\nMatrices\nConditionals\nLoops (for)\nVendoring\n\nSee the cpp11gaussjordan package.\n\nDetails\nThis implementation is a naive approach, but it can be used, for example, to obtain the Ordinary Least Squares (OLS) estimator as shown in the next section.\nVendoring means that the dependency code, the cpp11 C++ headers, are copied the project’s source tree. This ensures the dependency code is fixed and stable until it is updated.\nThe advantage of vendoring is that changes to the cpp11 package could never break the package’s code. The disadvantage is that fixes and new features will be available after vendoring the code again.\n\n\nVendoring\nI started with create_package(\"~/github/cpp11gaussjordan\"). I used VSCode but all my steps also apply to RStudio.\nAfter opening ~/github/cpp11gaussjordan I ran use_cpp11() to have a readily availably skeleton in my project.\nI ran use_apache_licence() to have a LICENSE file and indicate in DESCRIPTION that my package is distributed under the Apache License.\nThen I ran cpp_vendor() to copy the C++ headers into inst/include.\n\n\nBuilding and testing\nI used devtools to build and test the package:\n# build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n# test\n\nA &lt;- matrix(c(2,1,3,-1), nrow = 2, ncol = 2)\ninvert_matrix(A)\n\n&gt; invert_matrix(A)\n     [,1] [,2]\n[1,]  0.2  0.6\n[2,]  0.2 -0.4\n\n\n\nNaive Ordinary Least Squares (OLS) estimator\nThis example package covers the following topics:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\n\nSee the cpp11ols package.\nThis implementation is extremely naive, quite similar to the Gauss-Jordan example with extra steps, and it is enough to show how to use C++ code within R.\nMy approach was to create one function per step, which means to create one function to obtain \\(X^tX\\), another for \\((X^tX)^{-1}\\) (e.g, implementing the Gauss-Jordan method to invert a matrix), another for \\(X^tY\\) and then call each of those functions to obtain \\(\\hat{\\beta} = (X^tX)^{-1}(X^tY)\\).\nA good challenge would be to implement the QR decomposition used by the lm() function in R and use it to obtain the OLS estimator in C++. Drury (2016) provides a good starting point, this is not trivial to implement.\nIt is hard to beat the performance of the lm() function in R, which calls compiled C and FORTRAN functions, and these functions are fast and robust lm().\n\n\nLinear programming (Simplex phase 2)\nThis example package covers the following topics:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\nLoops (for and while)\nMessages\n\nSee the cpp11simplex package.\n\nAlgorithm\nThe simplex algorithm is well described in Introduction to Linear Optimization and there is efficient software to solve this, including Berkelaar and Csardi (2023).\nA problem written in canonical form is represented by a table such as:\n\\[\n\\begin{array}{ccc|c}\nx_1 & \\cdots & x_n & \\\\\n\\hline\nc_1 & \\cdots & c_n & -z \\\\\na_{11} & \\cdots & a_{1n} & b_1 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\na_{m1} & \\cdots & a_{mn} & b_m\n\\end{array}\n\\]\nwhere \\(c_1, \\ldots, c_n\\) are the coefficients of the objective function (i.e., costs), \\(a_{11}, \\ldots, a_{mn}\\) are the coefficients of the constraints, and \\(b_1, \\ldots, b_m\\) are the right-hand side of the constraints.\nThe simplex algorithm to solve the problem consists in the next steps:\n\nIf \\(c_j \\geq 0\\) for all \\(j\\), then the current solution is optimal. Basic variables are equal to \\(b_i\\) and non-basic variables are equal to 0.\nIf \\(c_j &lt; 0\\) for some \\(j\\), we choose it to enter the base. We chose the variable with the most negative \\(c_j\\), let’s say that it is \\(j = s\\).\nIf \\(a_{is} \\leq 0\\) for all \\(i\\), then the problem is unbounded.\nIf \\(a_{is} &gt; 0\\) for some \\(i\\), we choose \\(i = r\\) such that \\(\\frac{b_r}{a_{rs}} = \\min(\\frac{b_i}{a_is},\\: a_{is} 0)\\) and pivot on \\(a_{rs}\\), to then go back to step 1.\n\nThe coefficients are updated according to:\n\n\\(a_{ij} \\leftarrow a_{ij} - \\frac{a_{is} a_{rj}}{a_{rs}}\\) for \\(j \\neq s\\)\n\\(a_{rj} \\leftarrow \\frac{a_{rj}}{a_{rs}}\\)\n\\(b_i \\leftarrow b_i - \\frac{a_{is} b_r}{a_{rs}}\\) for \\(i \\neq r\\)\n\\(b_r \\leftarrow \\frac{b_r}{a_{rs}}\\)\n\\(c_j \\leftarrow c_j - \\frac{c_s a_{rj}}{a_{rs}}\\)\n\\(-z \\leftarrow -z - \\frac{c_s b_r}{a_{rs}}\\)\n\nThis algorithm is equivalent to Gauss method to solve linear systems.\n\n\nNumerical example\nA simple example is the following minimization problem:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 \\\\\n\\text{subject to} \\quad & x_1 + x_2 \\geq 3 \\\\\n& -3x_1 + x_2 \\geq 2 \\\\\n& x_1, x_2 \\geq 0\n\\end{aligned}\n\\]\nIn canonical form, this problem is:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 + 0x_3 + 0x_4 \\\\\n\\text{subject to} \\quad & x_1 + x_2 + x_3 = 3 \\\\\n& -3x_1 + x_2 + x_4 = 2 \\\\\n& x_1, x_2,x_3,x_4 \\geq 0\n\\end{aligned}\n\\]\nThe initial tableau for the problem is:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-1 & -3 & 0 & 0 & 0 \\\\\n1 & 1 & 1 & 0 & 3 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThe first row is the cost row, the last column is the right-hand side, and the rest is the matrix \\(A\\).\nThe first step is to pivot on row 2 and column 2:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-10 & 0 & 0 & 3 & 6 \\\\\n4 & 0 & 1 & -1 & 1 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThe second step is to pivot on row 2 and column 1:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n0 & 0 & 5/2 & 1/2 & 17/2 \\\\\n1 & 0 & 1/4 & -1/4 & 1/4 \\\\\n0 & 1 & 3/4 & 1/4 & 11/4\n\\end{array}\n\\]\nHere we reached a stopping criterion: the minimum cost is non-negative, therefore the solution is optimal and is \\(x^* = (\\frac{1}{4}, \\frac{11}{4}, 0 , 0)\\) with an optimal value \\(z^* = -\\frac{17}{2}\\).\n\n\nBuilding and testing\nI used devtools to build and test the package:\n## build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n## test\n\nc &lt;- c(-1, -3)\nb &lt;- c(3, 2)\n\nA &lt;- matrix(\n    c(1, -3, 1, 1),\n    nrow = 2,\n    ncol = 2,\n    byrow = FALSE\n)\n\ncpp11_simplex_phase2(c, b, A)\nThe result should be:\nInitial tableau:\n-1 -3  0  0  0 \n 1  1  1  0  3 \n-3  1  0  1  2 \nMinimum cost: -3\nPivot row: 2\nPivot column: 2\n====\nNew tableau:\n-10  0  0  3  6 \n 4  0  1 -1  1 \n-3  1  0  1  2 \nMinimum cost: -10\nPivot row: 1\nPivot column: 1\n====\nNew tableau:\n 0  0  2.5  0.5  8.5 \n 1  0  0.25 -0.25  0.25 \n 0  1  0.75  0.25  2.75 \nMinimum cost: 0\nOptimal solution found in 2 steps !\n\n\n\nUsing OMP (parallelization)\nThis example package covers the following topics:\n\nIntegers\nDoubles\nLists (unnamed and named)\nLoops (for)\nOpenMP parallelization\n\nSee the cpp11omp package.\n\nMotivation\nOne common phrase that I find when I need to Google how to do something with cpp11 is: “cpp11 does not offer OpenMP support.” This is a myth. cpp11 does offer OpenMP support. The requirements are: A processor and C++ compiler that support OpenMP.\nI tested this on Windows, where you need to install Rtools, and Ubuntu where I didn’t need anything special because the gcc compiler comes with the operating system and it just works.\nIf you are using macOS, you need to install libomp via Homebrew in order to extend the clang compiler, and this is explained in the OpenBox documentation (“Enable OpenMP on macOS For Building Scikit-Learn - OpenBox Documentation” n.d.).\n\n\nEnabling OpenMP\nI created an R package called cpp11omp with the following code:\nusethis::create_project(\"cpp11omp\")\nusethis::use_cpp11()\nThen, I created the file R/cpp11omp-package.R with the following contents:\n### usethis namespace: start\n#' @useDynLib cpp11omp, .registration = TRUE\n### usethis namespace: end\nNULL\nIn order to get the #pragma instruction to work, I needed to add the following to src/Makevars:\nPKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -DARMA_OPENMP_THREADS=1\nPKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS)\nCXX_STD = CXX11\nNot adding this means that the pragma instruction will be ignored and the functions will run in a single thread.\n\n\nUnnamed list\nI added a function called squared_unnamed_ in src/code.cpp that will square each element in a vector of doubles, so the file content corresponds to the following:\n#include &lt;cpp11.hpp&gt;\n#include &lt;omp.h&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] list squared_unnamed_(doubles x) {\n  // create vectors y = x^2 and z = thread number\n  int n = x.size();\n  writable::doubles y(n);\n  writable::doubles z(n);\n  \n  #pragma omp parallel for\n  for (int i = 0; i &lt; n; ++i) {\n    y[i] = x[i] * x[i];\n    z[i] = omp_get_thread_num();\n  }\n\n  //create a list containing y and z\n  writable::list out;\n  out.push_back(y);\n  out.push_back(z);\n  return out;\n}\nThe previous function returns an unnamed list with two elements: the squared vector and the thread number. The function is registered with [[cpp11::register]] so that it can be called from R.\nC++ is strict with types, so I need to create a wrapper function that will convert the integers to doubles to avoid accidental errors, it will go in R/cpp11omp-package.R:\n#' Unnamed list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_unnamed &lt;- function(x) {\n  squared_unnamed_(as.double(x))\n}\n\n\nNamed list\nI added a function called squared_named_ in src/code.cpp that does the same but returns a named list. The additional content corresponds to the following:\n[[cpp11::register]] list squared_named_(doubles x) {\n  // create vectors y = x^2 and z = thread number\n  int n = x.size();\n  writable::doubles y(n);\n  writable::doubles z(n);\n  \n  #pragma omp parallel for\n  for (int i = 0; i &lt; n; ++i) {\n    y[i] = x[i] * x[i];\n    z[i] = omp_get_thread_num();\n  }\n\n  //create a list containing y and z\n  writable::list out;\n  out.push_back({\"x^2\"_nm = y});\n  out.push_back({\"thread\"_nm = z});\n  return out;\n}\nAs in the previous part, I added a wrapper and documentation:\n#' Named list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_named &lt;- function(x) {\n  squared_named_(as.double(x))\n}\n\n\nBuilding and testing\nI used devtools to build and test the package:\ncpp11::cpp_register()\ndevtools::document()\ndevtools::install()\nThen, I tested the package from a new R session:\n&gt; library(cpp11omp)\n&gt; squared_unnamed(1:10)\n[[1]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[2]]\n [1] 0 0 1 1 2 3 4 5 6 7\n\n&gt; squared_named(1:10)\n$`x^2`\n [1]   1   4   9  16  25  36  49  64  81 100\n\n$thread\n [1] 0 0 1 1 2 3 4 5 6 7",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "10-worked-examples.html#useful-rc-integration-examples",
    "href": "10-worked-examples.html#useful-rc-integration-examples",
    "title": "Debugging R Packages",
    "section": "Useful R/C++ Integration Examples",
    "text": "Useful R/C++ Integration Examples\nHere are some examples of C++ code integration with R using the cpp11 package:\n\narrow: An R package that provides bindings to the Arrow C++ library. Arrow is a\ncolumnar in-memory analytics format that is extremely fast and efficient.\ncpp11armadillo: An R package that provides bindings to the Armadillo C++ library. Armadiilo is a high-quality linear algebra library with a syntax similar to MATLAB.\ncpp11eigen: An R package that provides bindings to the Eigen C++ library. Eigen is a high-performance linear algebra library with a permisive license.\ncpp11tesseract: An R package that provides bindings to the Tesseract OCR\nC++ engine. This package allows to extract text from images.\nhaven: A package that reads and writes SPSS, Stata, and SAS files in R.\nkendallknight: Implements the Kendall’s correlation coefficient in C++, achieving speedup by using an algorithm with a complexity of \\(O(n \\log(n))\\) instead of \\(O(n^2)\\) in base R.\nmice: A package that imputes missing data using multivariate chained equations.\nredatam: C++ implementation of the Redatam file format, callable from both R and Python.\nRPostgres: A C++ interface to PostgreSQL using cpp11.\ntidyr: A package that uses C++ functions to reshape data frames.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  },
  {
    "objectID": "10-worked-examples.html#references",
    "href": "10-worked-examples.html#references",
    "title": "Debugging R Packages",
    "section": "References",
    "text": "References\n\n\n\n\nBerkelaar, Michel, and Gabor Csardi. 2023. lpSolve: Interface to ’Lp_solve’ v. 5.5 to Solve Linear/Integer Programs. https://CRAN.R-project.org/package=lpSolve.\n\n\nDrury, Matthew. 2016. “A Deep Dive Into How R Fits a Linear Model.” http://madrury.github.io/jekyll/update/statistics/2016/07/20/lm-in-R.html.\n\n\n“Enable OpenMP on macOS For Building Scikit-Learn - OpenBox Documentation.” n.d. Accessed October 19, 2024. https://open-box.readthedocs.io/en/latest/installation/openmp_macos.html.\n\n\nPadgham, Mark. 2022. “Debugging in R with a Single Command.” https://mpadge.github.io/blog/blog012.html.\n\n\nVaughan, Davis. 2019. “Debugging an R Package with C++ – Davis Vaughan.” https://blog.davisvaughan.com/posts/2019-04-05-debug-r-package-with-cpp/.\n\n\nVaughan, Davis, Jim Hester, and Roman Francois. 2024. “Get Started with Cpp11.” https://cpp11.r-lib.org/articles/cpp11.html#intro.\n\n\nWickham, Hadley, and Jenny Bryan. 2023. “R Packages (2e).” https://r-pkgs.org/.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Debugging R Packages</span>"
    ]
  }
]