[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "C++ for R Users",
    "section": "",
    "text": "Motivation\nHere is a collection of my very own C++ errors and how I try to solve them.\nIn particular, these notes are for ECE244 (Programming Fundamentals) at the University of Toronto.\nI tend to lose focus and get distracted. Therefore, I prefer to organize my notes to minimize the likelihood of that.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "index.html#honest-disclaimer",
    "href": "index.html#honest-disclaimer",
    "title": "C++ for R Users",
    "section": "Honest Disclaimer",
    "text": "Honest Disclaimer\nThese notes are a summary of what worked after hours of fails for my future self. I hope it helps you too.\nI am a Statistician and Political Scientist, not a Computer Scientist!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Motivation</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html",
    "href": "05-rolling-functions.html",
    "title": "Rolling functions",
    "section": "",
    "text": "Required packages\nNeeded to visualize and simplify showing the results.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(patchwork)\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-sum-cumsum",
    "href": "05-rolling-functions.html#cumulative-sum-cumsum",
    "title": "Rolling functions",
    "section": "Cumulative sum (cumsum())",
    "text": "Cumulative sum (cumsum())\nTo be able to create writable vectors, I need to append this below the namespace declaration (i.e., using namespace cpp11).\nnamespace writable = cpp11::writable;\nThis function returns the cumulative sum of the elements of a vector.\n[[cpp11::register]] doubles cumsum_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\nThe R equivalent is the following.\n#' Return the cumulative sum of the coordinates of a vector (R)\n#' @param x numeric vector\n#' @export\ncumsum_r &lt;- function(x) {\n  n &lt;- length(x)\n  out &lt;- numeric(n)\n  out[1] &lt;- x[1]\n  for (i in 2:n) {\n    out[i] &lt;- out[i - 1] + x[i]\n  }\n  out\n}\nI also need to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative sum of the coordinates of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncumsum_cpp &lt;- function(x) {\n  cumsum_cpp_(as.double(x))\n}\nA benchmark of the two functions is the following.\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(1:3)\n\n[1] 1 3 6\n\ncumsum_cpp(1:3)\n\n[1] 1 3 6\n\ncumsum_r(1:3)\n\n[1] 1 3 6\n\nmark(\n  cumsum(x),\n  cumsum_cpp(x),\n  cumsum_r(x)\n)\n\n# A tibble: 3 × 6\n  expression         min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)       2.24ms   2.44ms     409.     3.81MB    83.7 \n2 cumsum_cpp(x)  26.62ms  29.99ms      34.1   15.26MB    54.6 \n3 cumsum_r(x)    45.45ms  46.95ms      21.0    7.66MB     4.66\n\n\nMy C++ function is in the middle between R’s cumsum() and my R function cumsum_r().",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-product-cumprod",
    "href": "05-rolling-functions.html#cumulative-product-cumprod",
    "title": "Rolling functions",
    "section": "Cumulative product (cumprod())",
    "text": "Cumulative product (cumprod())\nIn R we can use cumprod() to compute the cumulative product of a vector.\n\ncumprod(1:5)\n\n[1]   1   2   6  24 120\n\n\nThe C++ implementation can use the shortcuts from the previous part.\n[[cpp11::register]] cpp11::doubles cumprod_cpp_(cpp11::doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n  out[0] = x[0];\n  for(int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] * x[i];\n  }\n  return out;\n}\nTest correctness.\n\ncumprod(1:5)\n\n[1]   1   2   6  24 120\n\ncumprod_cpp_(1:5)\n\nError: Invalid input type, expected 'double' actual 'integer'\n\n\nI need an auxiliary function to cast the input as double.\n#' Return the cumulative product of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\ncumprod_cpp &lt;- function(x) {\n  cumprod_cpp_(as.double(x))\n}\nNow I can test the correctness of the function again.\n\ncumprod(1:5)\n\n[1]   1   2   6  24 120\n\ncumprod_cpp(1:5)\n\n[1]   1   2   6  24 120\n\n\nBenchmark.\n\nmark(\n  cumprod(x),\n  cumprod_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)       1.72ms   2.23ms     365.     15.3MB    309. \n2 cumprod_cpp(x)  26.27ms  28.46ms      34.9    15.3MB     17.5\n\n\nThe C++ implementation is slower than base R.\nOne remedial solution is not to define the length of the vector and add one coordinate on each step.\n[[cpp11::register]] doubles cumprod_cpp_2_(doubles x) {\n  int n = x.size();\n  writable::doubles out;\n  out.push_back(x[0]);\n  for(int i = 1; i &lt; n; ++i) {\n    out.push_back(out[i - 1] * x[i]);\n  }\n  return out;\n}\nBenchmark.\n\nresults &lt;- mark(\n  cumprod(x),\n  cumprod_cpp(x),\n  cumprod_cpp_(as.double(x)),\n  cumprod_cpp_2_(as.double(x))\n)\n\nresults %&gt;%\n  unnest(c(time, mem_alloc, gc)) %&gt;%\n  select(expression, time, mem_alloc, gc) %&gt;%\n  filter(gc == \"none\") %&gt;%\n  ggplot(aes(x = mem_alloc, y = time, color = expression)) +\n  geom_point() +\n  scale_color_viridis_d() +\n  geom_smooth(method = \"lm\", se = F, colour = \"grey50\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\ncumprod_cpp_2_ is faster than cumprod_cpp_ but still slower than base R, and it uses more memory than any of the compared function calls.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-minimum-cummin",
    "href": "05-rolling-functions.html#cumulative-minimum-cummin",
    "title": "Rolling functions",
    "section": "Cumulative minimum (cummin())",
    "text": "Cumulative minimum (cummin())\nLet’s look at this example from R’s documentation.\n\nc(3:1, 2:0, 4:2)\n\n[1] 3 2 1 2 1 0 4 3 2\n\ncummin(c(3:1, 2:0, 4:2))\n\n[1] 3 2 1 1 1 0 0 0 0\n\n\nThe function starts with the first element and then it compares the next element with the current minimum and keeps the smallest value. In this case, when it reaches zero, the next values in the sequence are zeroes because there are no negative values in the original vector.\nThe lesson from the previous part is to avoid growing vectors, it uses more memory.\nThe C++ implementation can use the learning from the previous parts.\n[[cpp11::register]] doubles cummin_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    // error: taking address of rvalue [-fpermissive]\n    // double* x1 = &out[i - 1];\n    double x1 = out[i - 1];\n\n    // error: lvalue required as unary ‘&’ operand\n    // double* x2 = &x[i];\n    double x2 = x[i];\n\n    out[i] = std::min(x1, x2);\n  }\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative minimum of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\ncummin_cpp &lt;- function(x) {\n  cummin_cpp_(as.double(x))\n}\nTest correctness and benchmark.\n\ncummin(c(3:1, 2:0, 4:2))\n\n[1] 3 2 1 1 1 0 0 0 0\n\ncummin_cpp(c(3:1, 2:0, 4:2))\n\n[1] 3 2 1 1 1 0 0 0 0\n\n# create random vectors\nset.seed(123) # for reproducibility\nbigx &lt;- list(\n  as.double(rpois(2e6, lambda = 2)),\n  as.double(rpois(4e6, lambda = 2)),\n  as.double(rpois(8e6, lambda = 2)),\n  as.double(rpois(16e6, lambda = 2)),\n  as.double(rpois(32e6, lambda = 2)),\n  as.double(rpois(64e6, lambda = 2))\n)\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    cummin(.x),\n    cummin_cpp(.x)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#cumulative-maximum-cummax",
    "href": "05-rolling-functions.html#cumulative-maximum-cummax",
    "title": "Rolling functions",
    "section": "Cumulative maximum (cummax())",
    "text": "Cumulative maximum (cummax())\nAnalogous to the previous part.\n[[cpp11::register]] doubles cummax_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n);\n\n  out[0] = x[0];\n  for (int i = 1; i &lt; n; ++i) {\n    // error: taking address of rvalue [-fpermissive]\n    // double* x1 = &out[i - 1];\n    double x1 = out[i - 1];\n\n    // error: lvalue required as unary ‘&’ operand\n    // double* x2 = &x[i];\n    double x2 = x[i];\n\n    out[i] = std::max(x1, x2);\n  }\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative maximum of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\ncummax_cpp &lt;- function(x) {\n  cummax_cpp_(as.double(x))\n}\nTest correctness and benchmark.\n\ncummax(c(3:1, 2:0, 4:2))\n\n[1] 3 3 3 3 3 3 4 4 4\n\ncummax_cpp(c(3:1, 2:0, 4:2))\n\n[1] 3 3 3 3 3 3 4 4 4\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    cummax(.x),\n    cummax_cpp(.x)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#lagged-differences-diff",
    "href": "05-rolling-functions.html#lagged-differences-diff",
    "title": "Rolling functions",
    "section": "Lagged Differences (diff())",
    "text": "Lagged Differences (diff())\n\nFirst order\nA simple example in R is.\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(10, lambda = 2)\nx\n\n [1] 1 3 2 4 4 0 2 4 2 2\n\ndiff(x, 1)\n\n[1]  2 -1  2  0 -4  2  2 -2  0\n\n\nThe C++ implementation is the following.\n[[cpp11::register]] doubles diff1_cpp_(doubles x) {\n  int n = x.size();\n  writable::doubles out(n - 1);\n\n  for (int i = 0; i &lt; n - 1; ++i) {\n    out[i] = x[i + 1] - x[i];\n  }\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the first order lagged differences of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\ndiff1_cpp &lt;- function(x) {\n  diff1_cpp_(as.double(x))\n}\nTest correctness.\n\ndiff(x, 1)\n\n[1]  2 -1  2  0 -4  2  2 -2  0\n\ndiff1_cpp(x)\n\n[1]  2 -1  2  0 -4  2  2 -2  0\n\n\n\n\nN-th order\nA simple example in R is.\n\ndiff(x, 2)\n\n[1]  1  1  2 -4 -2  4  0 -2\n\n\nThe C++ implementation is the following.\n[[cpp11::register]] doubles diff_cpp_(doubles x, int lag = 1) {\n  int n = x.size();\n  writable::doubles out(n - lag);\n\n  for (int i = 0; i &lt; n - lag; ++i) {\n    out[i] = x[i + lag] - x[i];\n  }\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the n-th order lagged differences of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\ndiff_cpp &lt;- function(x, lag = 1) {\n  diff_cpp_(as.double(x), as.integer(lag))\n}\nTest correctness.\n\ndiff(x, 2)\n\n[1]  1  1  2 -4 -2  4  0 -2\n\ndiff_cpp(x, 2)\n\n[1]  1  1  2 -4 -2  4  0 -2\n\n\nBenchmark.\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    diff(.x, 2),\n    diff_cpp(.x, 2)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#range-of-values-range",
    "href": "05-rolling-functions.html#range-of-values-range",
    "title": "Rolling functions",
    "section": "Range of values (range())",
    "text": "Range of values (range())\nA simple example in R is.\n\nrange(x)\n\n[1] 0 4\n\n\nThe C++ implementation is the following.\n[[cpp11::register]] doubles range_cpp_(doubles x) {\n  int n = x.size();\n  double x1 = x[0], x2 = x[0];\n\n  for (int i = 1; i &lt; n; ++i) {\n    x1 = std::min(x1, x[i]);\n    x2 = std::max(x2, x[i]);\n  }\n\n  writable::doubles out(2);\n  out[0] = x1;\n  out[1] = x2;\n\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the n-th order lagged differences of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @export\nrange_cpp &lt;- function(x) {\n  range_cpp_(as.double(x))\n}\nTest correctness.\n\nrange(x)\n\n[1] 0 4\n\nrange_cpp(x)\n\n[1] 0 4\n\n\nBenchmark.\n\nresults &lt;- map(\n  bigx,\n  ~ mark(\n    range(.x),\n    range_cpp(.x)\n  ) %&gt;%\n    mutate(n = length(.x))\n)\n\nd &lt;- results %&gt;%\n  bind_rows() %&gt;%\n  unnest(c(time, mem_alloc, gc, n)) %&gt;%\n  select(expression, time, mem_alloc, gc, n)\n\ng1 &lt;- ggplot(d, aes(x = n, y = time, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng2 &lt;- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +\n  geom_jitter(width = 0.01, height = 0.01) +\n  scale_color_viridis_d() +\n  theme_minimal()\n\ng1 / g2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "05-rolling-functions.html#references",
    "href": "05-rolling-functions.html#references",
    "title": "Rolling functions",
    "section": "References",
    "text": "References\n\nGet started with cpp11",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Rolling functions</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html",
    "href": "06-statistical-functions-2.html",
    "title": "Statistical functions with missing values",
    "section": "",
    "text": "Sum of Vector Elements (sum())\nThe following function returns the sum of the elements of a vector.\nI also have to add the corresponding auxiliary function for the documentation.\nTo test, I run the following lines in the R console.\nlibrary(bench)\n\nset.seed(123) # for reproducibility\nx &lt;- runif(1e3) # 1,000,000 elements\nx[sample(1:1e3, 1e2)] &lt;- NA # change some elements to NA at random\n\nsum(x, na.rm = FALSE)\n\n[1] NA\n\nsum2_cpp(x, na_rm = FALSE)\n\n[1] NA\n\nsum(x, na.rm = TRUE)\n\n[1] 447.4191\n\nsum2_cpp(x, na_rm = TRUE)\n\n[1] 447.4191\n\nmark(\n  sum(x, na.rm = TRUE),\n  sum2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum(x, na.rm = TRUE)         777ns    815ns  1127489.        0B        0\n2 sum2_cpp(x, na_rm = TRUE)   11.1µs   11.7µs    80548.        0B        0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "href": "06-statistical-functions-2.html#sum-of-vector-elements-sum",
    "title": "Statistical functions with missing values",
    "section": "",
    "text": "[[cpp11::register]] double sum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n  double total = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      total += x[i];\n    }\n  }\n  return total;\n}\n\n#' Return the sum of the coordinates of a vector (C++)\n#' @inheritParams sum_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  sum2_cpp_(as.double(x), na_rm = na_rm)\n}",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "href": "06-statistical-functions-2.html#arithmetic-mean-mean",
    "title": "Statistical functions with missing values",
    "section": "Arithmetic Mean (mean())",
    "text": "Arithmetic Mean (mean())\nThis function returns the average (or mean) of the elements of a vector.\n[[cpp11::register]] double mean2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  int m = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  double y = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      y += x[i];\n    }\n  }\n\n  return y / m;\n}\nI also need to add the corresponding auxiliary function for the documentation.\n#' Return the mean of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nmean2_cpp &lt;- function(x, na_rm = FALSE) {\n  mean2_cpp_(as.double(x), na_rm = na_rm)\n}\nA benchmark of the two functions is the following.\n\nmean(x)\n\n[1] NA\n\nmean2_cpp(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 0.4971323\n\nmean2_cpp(x, na_rm = TRUE)\n\n[1] 0.4971323\n\nmark(\n  mean(x, na.rm = TRUE),\n  mean2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                      min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 mean(x, na.rm = TRUE)        6.93µs   7.97µs   104027.    22.5KB     41.6\n2 mean2_cpp(x, na_rm = TRUE)  18.11µs  18.96µs    51371.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#variance-var",
    "href": "06-statistical-functions-2.html#variance-var",
    "title": "Statistical functions with missing values",
    "section": "Variance (var())",
    "text": "Variance (var())\nThis function returns the variance of the elements of a vector.\n[[cpp11::register]] double var2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  if (n &lt; 2) {\n    return NA_REAL;\n  }\n\n  int m = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n    }\n  }\n\n  if (m &lt; 2) {\n    return NA_REAL;\n  }\n\n  double ex = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      ex += x[i];\n    }\n  }\n  ex /= m;\n\n  double out = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      out += pow(x[i] - ex, 2);\n    }\n  }\n\n  return out / (m - 1);\n}\nI also need to add the corresponding auxiliary function for the documentation.\n#' Return the variance of the coordinates of a vector (C++)\n#' @inheritParams sum2_cpp\n#' @export\nvar2_cpp &lt;- function(x, na_rm = FALSE) {\n  var2_cpp_(as.double(x), na_rm = na_rm)\n}\nA benchmark of the two functions is the following.\n\nvar(x)\n\n[1] NA\n\nvar2_cpp(x)\n\n[1] NA\n\nvar(x, na.rm = TRUE)\n\n[1] 0.08155043\n\nvar2_cpp(x, na_rm = TRUE)\n\n[1] 0.08155043\n\nmark(\n  var(x, na.rm = TRUE),\n  var2_cpp(x, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                     min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 var(x, na.rm = TRUE)        7.35µs   8.54µs   110455.    3.95KB     33.1\n2 var2_cpp(x, na_rm = TRUE)  44.51µs  46.09µs    21216.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#root-mean-square-error",
    "href": "06-statistical-functions-2.html#root-mean-square-error",
    "title": "Statistical functions with missing values",
    "section": "Root Mean Square Error",
    "text": "Root Mean Square Error\nThe next function returns the measure of the differences between the observed values or an estimator (x1, x2, …, xn) and the true value (x0). For example, x1, …, xn could be experimental averages and x0 the true average.\n[[cpp11::register]] double rmse2_cpp_(doubles x, double x0) {\n  int n = x.size();\n\n  int m = 0;\n  for (int i = 0; i &lt; n; ++i) {\n    if (ISNAN(x[i])) {\n      continue;\n    } else {\n      ++m;\n    }\n  }\n\n  if (m == 0) {\n    return NA_REAL;\n  }\n\n  double out;\n  for (int i = 0; i &lt; n; ++i) {\n    if (na_rm && ISNAN(x[i])) {\n      continue;\n    } else {\n      out += pow(x[i] - x0, 2.0);\n    }\n  }\n  return sqrt(out / m);\n}\nI also need to add the corresponding auxiliary function for the documentation.\n#' Return the root mean square error (C++)\n#' @inheritParams rmse_r\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\nrmse2_cpp &lt;- function(x, x0, na_rm = FALSE) {\n  rmse2_cpp_(as.double(x), as.double(x0), na_rm = na_rm)\n}\nA benchmark of the base R versus C++ implementation is the following.\n\n# create a list with 100 normal distributions with mean 0 and 1 million elements\n# each\nset.seed(123) # for reproducibility\nx &lt;- list()\nfor (i in 1:1e3) {\n  x[[i]] &lt;- rnorm(1e3)\n}\n\n# compute the mean of each distribution\nx &lt;- sapply(x, mean)\n\n# remove some elements at random\nx[sample(1:1e3, 1e2)] &lt;- NA\n\nrmse2_cpp(x, 0)\n\n[1] NA\n\nrmse2_cpp(x, 0, na_rm = TRUE)\n\n[1] 0.02992032\n\nmark(\n  sqrt(mean((x - 0)^2, na.rm = TRUE)),\n  rmse2_cpp(x, 0, na_rm = TRUE)\n)\n\n# A tibble: 2 × 6\n  expression                            min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                        &lt;bch:t&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sqrt(mean((x - 0)^2, na.rm = TRU…  8.37µs  9.36µs   100294.    30.4KB     60.2\n2 rmse2_cpp(x, 0, na_rm = TRUE)     33.46µs  34.8µs    28194.        0B      0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "06-statistical-functions-2.html#references",
    "href": "06-statistical-functions-2.html#references",
    "title": "Statistical functions with missing values",
    "section": "References",
    "text": "References\n\nGet started with cpp11",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Statistical functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html",
    "href": "07-rolling-functions-2.html",
    "title": "Rolling functions with missing values",
    "section": "",
    "text": "Required packages\nNeeded to visualize and simplify showing the results.\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(patchwork)\nlibrary(bench)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "href": "07-rolling-functions-2.html#cumulative-sum-cumsum",
    "title": "Rolling functions with missing values",
    "section": "Cumulative sum (cumsum())",
    "text": "Cumulative sum (cumsum())\nThis function returns the cumulative sum of the elements of a vector.\n[[cpp11::register]] doubles cumsum2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 + 0.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 0.0 + y2;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 + y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nI also need to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative sum of the coordinates of a vector (C++)\n#' @param x numeric vector\n#' @param na_rm logical. Should missing values (including `NaN`) be removed?\n#' @export\ncumsum2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumsum2_cpp_(as.double(x), na_rm = na_rm)\n}\nA benchmark of the two functions is the following.\n\nset.seed(123) # for reproducibility\nx &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements\n\ncumsum(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumsum2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 3 7\n\nmark(\n  cumsum(x),\n  cumsum2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumsum(x)        1.83ms   1.89ms     513.     3.81MB     73.2\n2 cumsum2_cpp(x)  30.93ms  35.35ms      28.3   15.26MB     33.0",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "href": "07-rolling-functions-2.html#cumulative-product-cumprod",
    "title": "Rolling functions with missing values",
    "section": "Cumulative product (cumprod())",
    "text": "Cumulative product (cumprod())\nThe C++ implementation is similar to the previous part.\n[[cpp11::register]] doubles cumprod2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = y1 * 1.0;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = 1.0 * y2;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = y1 * y2;\n        }\n      }\n    }\n  }\n\n  return out;\n}\nI need an auxiliary function to cast the input as double.\n#' Return the cumulative product of the coordinates of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncumprod2_cpp &lt;- function(x, na_rm = FALSE) {\n  cumprod2_cpp_(as.double(x), na_rm = na_rm)\n}\nTest correctness and Benchmark.\n\ncumprod(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncumprod2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 8\n\nmark(\n  cumprod(x),\n  cumprod2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cumprod(x)        1.88ms   2.08ms     339.     15.3MB    418. \n2 cumprod2_cpp(x)  30.61ms  31.59ms      31.2    15.3MB     18.7",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "href": "07-rolling-functions-2.html#cumulative-minimum-cummin",
    "title": "Rolling functions with missing values",
    "section": "Cumulative minimum (cummin())",
    "text": "Cumulative minimum (cummin())\nThe C++ implementation is similar to the previous part.\n[[cpp11::register]] doubles cummin2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = x[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::min(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::min(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative minimum of the coordinates of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncummin2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummin2_cpp_(as.double(x), na_rm = na_rm)\n}\nTest correctness and benchmark.\n\ncummin(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummin2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 1 1\n\nmark(\n  cummin(x),\n  cummin2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummin(x)        1.16ms   1.24ms     647.     3.81MB     67.9\n2 cummin2_cpp(x)  32.16ms  34.32ms      29.2   15.26MB     43.8",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "href": "07-rolling-functions-2.html#cumulative-maximum-cummax",
    "title": "Rolling functions with missing values",
    "section": "Cumulative maximum (cummax())",
    "text": "Cumulative maximum (cummax())\nThe C++ implementation is similar to the previous part.\n[[cpp11::register]] doubles cummax2_cpp_(doubles x, bool na_rm = false) {\n  int n = x.size();\n\n  writable::doubles out(n);\n  out[0] = x[0];\n\n  if (na_rm == true) {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y1)) {\n        out[i] = y2;\n      } else {\n        out[i] = std::max(y1, y2);\n      }\n    }\n  } else {\n    for (int i = 1; i &lt; n; ++i) {\n      double y1 = out[i - 1], y2 = x[i];\n      if (ISNAN(y2)) {\n        out[i] = NA_REAL;\n      } else {\n        if (ISNAN(y1)) {\n          out[i] = NA_REAL;\n        } else {\n          out[i] = std::max(y1, y2);\n        }\n      }\n    }\n  }\n\n  return out;\n}\nI also have to add the corresponding auxiliary function for the documentation.\n#' Return the cumulative maximum of the coordinates of a vector (C++)\n#' @inheritParams cumsum_r\n#' @export\ncummax2_cpp &lt;- function(x, na_rm = FALSE) {\n  cummax2_cpp_(as.double(x), na_rm = na_rm)\n}\nTest correctness and benchmark.\n\ncummax(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4))\n\n[1]  1 NA NA NA\n\ncummax2_cpp(c(1, NA, 2, 4), na_rm = TRUE)\n\n[1] 1 1 2 4\n\nmark(\n  cummax(x),\n  cummax2_cpp(x)\n)\n\n# A tibble: 2 × 6\n  expression          min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 cummax(x)        1.06ms   1.13ms     868.     3.81MB     59.0\n2 cummax2_cpp(x)  32.27ms  32.62ms      30.6   15.26MB     11.1",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "07-rolling-functions-2.html#references",
    "href": "07-rolling-functions-2.html#references",
    "title": "Rolling functions with missing values",
    "section": "References",
    "text": "References\n\nGet started with cpp11",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Rolling functions with missing values</span>"
    ]
  },
  {
    "objectID": "08-creating-r-packages.html",
    "href": "08-creating-r-packages.html",
    "title": "Creating real R packages",
    "section": "",
    "text": "Creating an R package with C++ code\nOriginally available in my blog.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creating real R packages</span>"
    ]
  },
  {
    "objectID": "08-creating-r-packages.html#creating-an-r-package-with-c-code",
    "href": "08-creating-r-packages.html#creating-an-r-package-with-c-code",
    "title": "Creating real R packages",
    "section": "",
    "text": "Motivation\nUsing a compiled language such as C++ is justified when it is challenging to vectorize R code, or when the code is computationally intensive and we need repeated calls of the same function that justify the time invested in re-writing R code code in C++.\n\n\nSetup\nUbuntu and its derived distributions use gcc as the default C++ compiler. I will use g++ just for consistency with what is used at the University of Toronto in the ECE244 course.\nAccording to Ubuntu documentation: “When you compile C++ programs, you should invoke GCC as g++ instead.”\nI installed the R packages cpp11 and usethis:\ninstall.packages(c(\"cpp11\", \"usethis\"))\nI created a file ~/.Rprofile containing the following lines:\nlibrary(devtools)\nlibrary(usethis)\nlibrary(cpp11)\nNow forget about devtools::install(). After reopening your editor, every time you use RStudio (or VSCode) you just call install(), and the same applies to usethis::use_*() and cpp11::cpp_*() functions.\nUp to this point I still had the following error messages when compiling C++ code:\nfatal error: 'cstdio' file not found\nfatal error: 'vector' file not found\ncannot find -lc++abi: No such file or directory\nI had to install additional packages. This took me a few hours searching on the Internet until I figured it out. Install the following packages:\nsudo apt install g++-11 libc++-11-dev libc++abi-11-dev\nTo be sure that the install() function in R uses g++, I created the ~/.R/Makevars file. The contents of the file are the following:\nCC = gcc\nCXX = g++\nCXX98 = g++\nCXX11 = g++\nCXX14 = g++\nCXX14 = g++\nCXX17 = g++\nCXX20 = g++\nCXXCPP = g++\nOBJC = gcc\nOBJCXX = g++\nSHLIB_CXXLD = g++\n\n# USE -O0 for debugging\n# USE -O3 for production code\nCXXFLAGS=-Wall -O3 -pedantic\nCXX11FLAGS=-Wall -O3 -pedantic\nCXX14FLAGS=-Wall -O3 -pedantic\nCXX17FLAGS=-Wall -O3 -pedantic\nCXX20FLAGS=-Wall -O3 -pedantic\nA more flexible approach is to edit src/Makevars within the package folder, and add the following lines:\nPKG_CXXFLAGS = -Wall -O0 -pedantic\nIn the CXXFLAGS I use -O0 to avoid optimization, which is useful for debugging. After the code is working, I can change it to -O3 to optimize the compiled code.\nIf later on I need to compile with gcc, I can open ~/.R/Makevars, comment all the lines, restart RStudio or VSCode, and run install() again.\nIf you close RStudio (or VSCode) and open it again, you can check that the changes were implemented by running this code:\n\ncpp11::cpp_source(\n  code = \"\n    #include &lt;cpp11.hpp&gt;\n\n    using namespace cpp11;\n\n    [[cpp11::register]] int plusone(int x)\n    {\n        return x + 1;\n    }\",\n  quiet = FALSE\n)\n\nusing C++ compiler: ‘g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\nusing C++11\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpWztjQ8/file2278e58f5ee32/src/code_2278e7f036a0f.cpp -o /tmp/RtmpWztjQ8/file2278e58f5ee32/src/code_2278e7f036a0f.o\ng++ -std=gnu++11 -I\"/usr/share/R/include\" -DNDEBUG -I'/home/pacha/R/x86_64-pc-linux-gnu-library/4.4/cpp11/include'      -fpic  -g -O2 -ffile-prefix-map=/build/r-base-2y82rL/r-base-4.4.1=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2   -c /tmp/RtmpWztjQ8/file2278e58f5ee32/src/cpp11.cpp -o /tmp/RtmpWztjQ8/file2278e58f5ee32/src/cpp11.o\ng++ -std=gnu++11 -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -flto=auto -ffat-lto-objects -flto=auto -Wl,-z,relro -o /tmp/RtmpWztjQ8/file2278e58f5ee32/src/code_2278e7f036a0f.so /tmp/RtmpWztjQ8/file2278e58f5ee32/src/code_2278e7f036a0f.o /tmp/RtmpWztjQ8/file2278e58f5ee32/src/cpp11.o -L/usr/lib/R/lib -lR\n\n\nThe output should start with:\nusing C++ compiler: ‘g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\nInstead of:\nusing C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\n\n\nCreating a dummy package\nFrom RStudio (or VSCode) we can create a new package by running create_package(\"~/cpp11dummypackage\"). This will create a new folder with the name cpp11dummypackage. Then I run use_cpp11() to add the required files to use C++ code within R.\nThen I run use_r(\"cpp11dummypackage-package\") to create a new R script file with the name cpp11dummypackage-package.R within the R folder, and added the following code to it:\n#' @useDynLib cpp11dummypackage, .registration = TRUE\nNULL\nThe usethis skeleton also created the file src/code.cpp for us. I added a simple function to transpose a matrix to it, by replacing the file contents by the following lines:\n#include &lt;cpp11.hpp&gt;\n\nusing namespace cpp11;\n    \n[[cpp11::register]] doubles_matrix&lt;&gt; transpose_(doubles_matrix&lt;&gt; X)\n{\n    int NX = X.nrow();\n    int MX = X.ncol();\n\n    writable::doubles_matrix&lt;&gt; R(MX, NX);\n\n    for (int i = 0; i &lt; MX; i++)\n    {\n        for (int j = 0; j &lt; NX; j++)\n        {\n            R(i, j) = X(j, i);\n        }\n    }\n\n    return R;\n}\nIn order to export the function, I added the following lines to cpp11dummypackage-package.R:\n#' Transpose a matrix\n#' @export\n#' @param X numeric matrix\n#' @return numeric matrix\n#' @examples\n#' set.seed(1234)\n#' X &lt;- matrix(rnorm(4), nrow = 2, ncol = 2)\n#' X\n#' transpose(X)\ntranspose &lt;- function(X) {\n  transpose_(X)\n}\nI tested the functions after running cpp11_register() and load_all():\n&gt; set.seed(1234)\n\n&gt; X &lt;- matrix(rnorm(4), nrow = 2, ncol = 2)\n\n&gt; X\n           [,1]      [,2]\n[1,] -1.2070657  1.084441\n[2,]  0.2774292 -2.345698\n\n&gt; transpose(X)\n          [,1]       [,2]\n[1,] -1.207066  0.2774292\n[2,]  1.084441 -2.3456977\nIf I would have passed 1:4 instead of rnorm(4) to matrix(), I would have obtained the following error message:\n&gt; transpose(X)\nError: Invalid input type, expected 'double' actual 'integer'\nThis is because I declared the function to accept a doubles_matrix&lt;&gt; as input, and not an integers_matrix&lt;&gt;.\nTo install the recently created package, I run the following lines in the R console:\nclean_dll()\ncpp_register()\ndocument()\ninstall()\nThen I can use the package in a new R session or another computer as follows:\n# install_github(\"pachadotdev/cpp11dummypackage\")\nlibrary(cpp11dummypackage)\n\nX &lt;- matrix(rnorm(4), nrow = 2, ncol = 2)\n\ntranspose(X)\n\n\nDebugging the package\nIn order to access debugging symbols, I created a new Makevars file within the src folder, and added the following lines:\nCXX_STD = CXX11\nPKG_CPPFLAGS = -UDEBUG -g\nThen I reinstalled the package compiled with debugging symbols, and in bash I run R -d lldb-11. From there I could follow this excellent guide to debug R and C++ code.\nYou shouldn’t generally leave the -g flag on in a Makevars file, that will insert trace symbols in the compiled binary, both increasing compilation times (often by a large margin), and creating larger binaries. Once the package is compiled and I am sure that it works properly, I need to remove the PKG_CPPFLAGS = -UDEBUG -g line.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creating real R packages</span>"
    ]
  },
  {
    "objectID": "08-creating-r-packages.html#instructional-examples",
    "href": "08-creating-r-packages.html#instructional-examples",
    "title": "Creating real R packages",
    "section": "Instructional examples",
    "text": "Instructional examples\n\nSolving a matrix using the Gauss-Jordan method\nSee the cpp11gaussjordan package.\nTopics covered:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\nLoops (for)\nVendoring\n\n\nDetails\nThis implementation is a naive approach, but it can be used, for example, to obtain the Ordinary Least Squares (OLS) estimator as shown in the next section.\nVendoring means that I copied the code for the dependencies into the project’s source tree (e.g., I copied the C++ headers provided by the cpp11 package into my own R package). This ensures the dependency code is fixed and stable until it is updated.\nThe advantage of vendoring is that changes to the cpp11 package could never break your existing code. The disadvantage is that you no longer get bugfixes and new features until you manually run cpp_vendor() in your project.\n\n\nBuilding and testing\nI used devtools to build and test the package:\n# build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n# test\n\nA &lt;- matrix(c(2,1,3,-1), nrow = 2, ncol = 2)\ninvert_matrix(A)\n\n&gt; invert_matrix(A)\n     [,1] [,2]\n[1,]  0.2  0.6\n[2,]  0.2 -0.4\n\n\nCreating an R package with C++ code and vendoring\nI started with create_package(\"~/github/cpp11gaussjordan\"). I used VSCode but all my steps also apply to RStudio.\nAfter opening ~/github/cpp11gaussjordan I ran use_cpp11() to have a readily availably skeleton in my project.\nI ran use_apache_licence() to have a LICENSE file and indicate in DESCRIPTION that my package is distributed under the Apache License.\nThen I ran cpp_vendor() to copy the C++ headers into inst/include.\n\n\n\nNaive Ordinary Least Squares (OLS) estimator\nSee the cpp11ols package.\nTopics covered:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\n\n\nDetails\nThis implementation is extremely naive, but it is enough to show how to use C++ code within R. Please see it from my GitHub profile.\nMy approach was to create one function per step, which meant to create one function to obtain \\(X^tX\\), another for \\((X^tX)^{-1}\\) which consisted in implementing the Gauss-Jordan method to invert a matrix, another for \\(X^tY\\) and then call each of those functions to obtain \\(\\hat{\\beta} = (X^tX)^{-1}(X^tY)\\).\nA good challenge would be to implement the QR decomposition used by the lm() function in R and use it to obtain the OLS estimator in C++. This would require some effort, but here you can find a good starting point.\nIn any case, it would be extremely hard to beat the performance of the lm() function in R, which has some internals written in C, and how computationally robust lm() is means another feature that is hard to beat.\n\n\n\nLinear programming (Simplex phase 2)\nSee the cpp11simplex package.\nTopics covered:\n\nIntegers\nDoubles\nDoubles matrices\nConditionals\nLoops (for and while)\nMessages\n\n\nAlgorithm\nThe simplex algorithm is well described in Introduction to Linear Optimization and there is efficient software to solve this.\nA problem written in canonical form is represented by a table such as:\n\\[\n\\begin{array}{ccc|c}\nx_1 & \\cdots & x_n & \\\\\n\\hline\nc_1 & \\cdots & c_n & -z \\\\\na_{11} & \\cdots & a_{1n} & b_1 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\na_{m1} & \\cdots & a_{mn} & b_m\n\\end{array}\n\\]\nwhere \\(c_1, \\ldots, c_n\\) are the coefficients of the objective function (i.e., costs), \\(a_{11}, \\ldots, a_{mn}\\) are the coefficients of the constraints, and \\(b_1, \\ldots, b_m\\) are the right-hand side of the constraints.\nThe simplex algorithm to solve the problem consists in the next steps:\n\nIf \\(c_j \\geq 0\\) for all \\(j\\), then the current solution is optimal. Basic variables are equal to \\(b_i\\) and non-basic variables are equal to 0.\nIf \\(c_j &lt; 0\\) for some \\(j\\), we choose it to enter the base. We chose the variable with the most negative \\(c_j\\), let’s say that it is \\(j = s\\).\nIf \\(a_{is} \\leq 0\\) for all \\(i\\), then the problem is unbounded.\nIf \\(a_{is} &gt; 0\\) for some \\(i\\), we choose \\(i = r\\) such that \\(\\frac{b_r}{a_{rs}} = \\min(\\frac{b_i}{a_is},\\: a_{is} 0)\\) and pivot on \\(a_{rs}\\), to then go back to step 1.\n\nThe coefficients are updated according to:\n\n\\(a_{ij} \\leftarrow a_{ij} - \\frac{a_{is} a_{rj}}{a_{rs}}\\) for \\(j \\neq s\\)\n\\(a_{rj} \\leftarrow \\frac{a_{rj}}{a_{rs}}\\)\n\\(b_i \\leftarrow b_i - \\frac{a_{is} b_r}{a_{rs}}\\) for \\(i \\neq r\\)\n\\(b_r \\leftarrow \\frac{b_r}{a_{rs}}\\)\n\\(c_j \\leftarrow c_j - \\frac{c_s a_{rj}}{a_{rs}}\\)\n\\(-z \\leftarrow -z - \\frac{c_s b_r}{a_{rs}}\\)\n\nThis algorithm is equivalent to Gauss method to solve linear systems.\n\n\nNumerical example\nLet’s say we want to solve the following linear programming problem:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 \\\\\n\\text{subject to} \\quad & x_1 + x_2 \\geq 3 \\\\\n& -3x_1 + x_2 \\geq 2 \\\\\n& x_1, x_2 \\geq 0\n\\end{aligned}\n\\]\nWe need to re-write the problem in canonical form:\n\\[\n\\begin{aligned}\n\\text{min} \\quad & -x_1 - 3x_2 + 0x_3 + 0x_4 \\\\\n\\text{subject to} \\quad & x_1 + x_2 + x_3 = 3 \\\\\n& -3x_1 + x_2 + x_4 = 2 \\\\\n& x_1, x_2,x_3,x_4 \\geq 0\n\\end{aligned}\n\\]\nThe initial tableau for this problem is:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-1 & -3 & 0 & 0 & 0 \\\\\n1 & 1 & 1 & 0 & 3 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThe first row is the cost row, the last column is the right-hand side, and the rest is the matrix \\(A\\).\nWe pivot on row 2, column 2:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n-10 & 0 & 0 & 3 & 6 \\\\\n4 & 0 & 1 & -1 & 1 \\\\\n-3 & 1 & 0 & 1 & 2\n\\end{array}\n\\]\nThen, we pivot on row 2, column 1:\n\\[\n\\begin{array}{cccc|c}\nx_1 & x_2 & x_3 & x_4 & -z \\\\\n\\hline\n0 & 0 & 5/2 & 1/2 & 17/2 \\\\\n1 & 0 & 1/4 & -1/4 & 1/4 \\\\\n0 & 1 & 3/4 & 1/4 & 11/4\n\\end{array}\n\\]\nHere we reached a stopping criterion: the minimum cost is non-negative, so we have found an optimal solution, which is \\(x^* = (\\frac{1}{4}, \\frac{11}{4}, 0 , 0)\\) and the optimal value is \\(z^* = -\\frac{17}{2}\\).\n\n\nBuilding and testing\nI used devtools to build and test the package:\n## build\n\ndevtools::clean_dll()\ncpp11::cpp_register()\ndevtools::document()\ndevtools::load_all()\n\n## test\n\nc &lt;- c(-1, -3)\nb &lt;- c(3, 2)\n\nA &lt;- matrix(\n    c(1, -3, 1, 1),\n    nrow = 2,\n    ncol = 2,\n    byrow = FALSE\n)\n\ncpp11_simplex_phase2(c, b, A)\nThe result should be:\nInitial tableau:\n-1 -3  0  0  0 \n 1  1  1  0  3 \n-3  1  0  1  2 \nMinimum cost: -3\nPivot row: 2\nPivot column: 2\n====\nNew tableau:\n-10  0  0  3  6 \n 4  0  1 -1  1 \n-3  1  0  1  2 \nMinimum cost: -10\nPivot row: 1\nPivot column: 1\n====\nNew tableau:\n 0  0  2.5  0.5  8.5 \n 1  0  0.25 -0.25  0.25 \n 0  1  0.75  0.25  2.75 \nMinimum cost: 0\nOptimal solution found in 2 steps !\n\n\n\nUsing OMP (parallelization)\nOriginally available in my blog.\nSee the cpp11omp package.\nTopics covered:\n\nIntegers\nDoubles\nLists\nLoops (for)\nOpenMP parallelization\n\n\nMotivation\nOne common phrase that I find when I need to Google how to do something with cpp11 is “Don’t use cpp11 because it does not offer OpenMP support.”\nThis is a myth. cpp11 does offer OpenMP support. In this blog post, I will show you how to use OpenMP with cpp11, but here I assume your C++ compiler already supports OpenMP.\nI tested this on Windows, where you need to install Rtools, and Linux Mint (Ubuntu based) where I didn’t need anything special because the gcc compiler comes with the operating system and just works. If you are using macOS, you need to install libomp via Homebrew in order to extend the clang compiler, and this is explained here.\n\n\nCreating a package\nFirst, we need to create a package. I will use usethis to create a package called cpp11omp:\nusethis::create_project(\"cpp11omp\")\nThen, I will add cpp11 as a dependency:\nusethis::use_cpp11()\nAs the cpp11 message indicates, I created a file called R/cpp11omp-package.R with the following contents:\n### usethis namespace: start\n#' @useDynLib cpp11omp, .registration = TRUE\n### usethis namespace: end\nNULL\n\n\nCpp11 unnamed list\nI added a function called squared_unnamed_ in src/code.cpp that will square each element in a vector of doubles, so the file content corresponds to the following:\n#include &lt;cpp11.hpp&gt;\n#include &lt;omp.h&gt;\n\nusing namespace cpp11;\n\n[[cpp11::register]] list squared_unnamed_(doubles x) {\n    // create vectors y = x^2 and z = thread number\n    int n = x.size();\n    writable::doubles y(n);\n    writable::doubles z(n);\n    #pragma omp parallel for\n    for (int i = 0; i &lt; n; ++i) {\n        y[i] = x[i] * x[i];\n        z[i] = omp_get_thread_num();\n    }\n\n    //create a list containing y and z\n    writable::list out;\n    out.push_back(y);\n    out.push_back(z);\n    return out;\n}\nThe previous function returns an unnamed list with two elements: the squared vector and the thread number. The function is registered with [[cpp11::register]] so that it can be called from R.\nIf I try to run square_unnamed_(1:10), it will return an error because I am passing a vector of integers instead of doubles. C++ is strict with types, so I need to create a wrapper function that will convert the integers to doubles, and it will go inside R/cpp11omp-package.R:\n#' Unnamed list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_unnamed &lt;- function(x) {\n  squared_unnamed_(as.double(x))\n}\nThe previous function is exported with @export so that it can be called by the end user. The function squared_unnamed_ is an internal function. This approach also has the advantage that I can document the function in a flexible way.\n\n\nCpp11 named list\nI added a function called squared_named_ in src/code.cpp that does the same but returns a named list. The additional content corresponds to the following:\n[[cpp11::register]] list squared_named_(doubles x) {\n    // create vectors y = x^2 and z = thread number\n    int n = x.size();\n    writable::doubles y(n);\n    writable::doubles z(n);\n    #pragma omp parallel for\n    for (int i = 0; i &lt; n; ++i) {\n        y[i] = x[i] * x[i];\n        z[i] = omp_get_thread_num();\n    }\n\n    //create a list containing y and z\n    writable::list out;\n    out.push_back({\"x^2\"_nm = y});\n    out.push_back({\"thread\"_nm = z});\n    return out;\n}\nAs in the previous part, I added a wrapper and documentation:\n#' Named list with squared numbers and the threads used\n#' @param x A vector of doubles\n#' @export\nsquared_named &lt;- function(x) {\n  squared_named_(as.double(x))\n}\n\n\nMakevars\nIn order to make the #pragma instruction work, I need to add the following to src/Makevars:\nPKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS)\nPKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS)\nCXX_STD = CXX11\nIf I don’t do this, the pragma instruction will be ignored and the functions will run in a single thread.\n\n\nBuilding and testing\nI used devtools to build and test the package:\ncpp11::cpp_register()\ndevtools::document()\ndevtools::install()\nThen, I tested the package from a new R session:\n&gt; library(cpp11omp)\n&gt; squared_unnamed(1:10)\n[[1]]\n [1]   1   4   9  16  25  36  49  64  81 100\n\n[[2]]\n [1] 0 0 1 1 2 3 4 5 6 7\n\n&gt; squared_named(1:10)\n$`x^2`\n [1]   1   4   9  16  25  36  49  64  81 100\n\n$thread\n [1] 0 0 1 1 2 3 4 5 6 7",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creating real R packages</span>"
    ]
  },
  {
    "objectID": "08-creating-r-packages.html#real-life-examples",
    "href": "08-creating-r-packages.html#real-life-examples",
    "title": "Creating real R packages",
    "section": "Real-life examples",
    "text": "Real-life examples\n\nArrow: An excellent package that uses pure C++ code called from R by using the cpp11 to read and write Apache Arrow files. The package is well documented and has a lot of tests. The package is also well maintained and has a lot of contributors.\nCpp11armadillo: A package that uses cpp11 to call C++ code from R to perform matrix operations using the Armadillo library. Armadillo is a very well documented C++ library with a syntax similar to MATLAB and it has been tested and improved for over ten years.\nKendallknight: A pure C++ implementation of the Kendall’s correlation coefficient. The algorithm is called in R by using the cpp11 package and it provides a speedup because the complexity goes from \\(O(n^2)\\) to \\(O(n \\log(n))\\) by counting inversions instead of using brute force.\nRedatam: A pure C++ implementation of the Redatam file format. The algorithm is called in R by using the cpp11 package and writes to an R list of data frames. Because of this cross-languages integration, it was very simple to also provide a Python package that calls C++ as the R package does.\nRPostgres: An amazing C++ Interface to PostgreSQL that uses cpp11 to call C++ code from R. The package is well documented and has a lot of tests. The package is also well maintained and has a lot of contributors.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creating real R packages</span>"
    ]
  },
  {
    "objectID": "08-creating-r-packages.html#references",
    "href": "08-creating-r-packages.html#references",
    "title": "Creating real R packages",
    "section": "References",
    "text": "References\n\nGet started with cpp11\nDebugging in R with a single command\nDebugging an R package with C++\nClang++ missing C++ header?\nHow to I tell RStudio not to ignore the indication to use clang in Makevars?\nR’s Makevars: PKG_CXXFLAGS vs. PKG_CXX11FLAGS\nDebugging memory errors with valgrind and gdb\nA Deep Dive Into How R Fits a Linear Model\nFixing R Package Installation Errors in MacOS Big Sur, Monterey & Ventura",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Creating real R packages</span>"
    ]
  }
]